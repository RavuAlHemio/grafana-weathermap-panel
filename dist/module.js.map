{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./svg-weathermap/weathermap.ts","webpack:///./module.ts","webpack:///./weathermapControl.ts","webpack:///./properties.ts","webpack:///./svg-weathermap/constants.ts","webpack:///./svg-weathermap/geometry.ts","webpack:///./svg-weathermap/gradients.ts","webpack:///./svg-weathermap/legend.ts"],"names":["installedModules","__webpack_require__","m","renderWeathermapInto","elementCreator","container","config","currentValues","linkResolver","addViewBox","sortedStops","gradient","stops","slice","sort","l","r","position","sortedGradient","type","state","WeathermapRendererState","svg","make","modifyStyle","canvasSize","width","height","setAttribute","appendChild","defs","legendGroup","g","edgeGroup","nodeGroup","labelGroup","nodeLinkUriBase","link","node","edgeLinkUriBase","edge","weathermapNodes","nodeLabelToNode","label","singleNodeGroup","maybeWrapIntoLink","linkParams","rect","setRectangleDimensions","x","y","text","textOffsets","left","bottom","showNumbers","metricName","value","textContent","currentValue","gradientColorForValue","noValueDashArray","unmeasuredDashArray","weathermapEdges","node1","node2","singleEdgeGroup","n1Center","n2Center","control1","control2","bendDirection","bendMagnitude","n1N2Angle","Math","atan2","n2N1Angle","n1N2BendAngle","normalizeAngle","deg2rad","n2N1BendAngle","control1Offset","polarToCartesian","control2Offset","metric2Name","point1COut","point2CIn","point2","point2COut","point3CIn","makeAndPlaceEdge","styleName","weathermapLabels","singleLabelGroup","placeLegend","legend","id","start","end","edgeStyleName","title","strokeWidths","strokeWidth","edgeStyle","styleMap","strokeWidthArray","split","map","p","Number","parseFloat","length","push","offsetUnitVector","direction","offsetVector","unitVector","multistrokeGroup","titleElem","element","style","styleProps","dashArray","currentOffset","reduce","acc","cur","isSpacing","xOffset","yOffset","strokeStart","strokeControl1","strokeControl2","strokeEnd","path","midpoint","halveCubicBezier","valueString","toFixed","svgMake","upperGroup","singleObjectGroup","linkUriBase","objLinkParams","objLinkUri","indexOf","aElement","a","setAttributeNS","xlinkNamespace","newValues","assembledStyle","hasAttribute","styleVal","getAttribute","chunk","index","key","substr","hasOwnProperty","keyValuePairs","keyValueString","join","domCreator","this","SVGElementCreator","weathermapStyles","name","maker","createElementNS","s","svgNamespace","linearGradient","stop","PanelCtrl","WeathermapCtrl","i","panelDefaults","valueName","nullPointMode","absoluteUri","dashboard","dashUri","addEditorTab","seriesData","series","onGradientStopStrokeColorChange","onGradientStopFillColorChange","t","objLink","search","dash","pluginName","point1","angleRadians","PI","vector","euclidNorm","angleDegrees","lastStop","parseInt","colorType","lerp","posFrom","posTo","sourceMin","sourceMax","settings","svgStop","c","d","exports","getter","o","Object","defineProperty","enumerable","get","Symbol","toStringTag","mode","__esModule","ns","create","bind","n","module","object","property","prototype","call","moduleId","modules"],"mappings":"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","file":"module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","import { svgNamespace, xlinkNamespace } from \"./constants\";\r\nimport { deg2rad, halveCubicBezier, normalizeAngle, Point2D, polarToCartesian, unitVector } from \"./geometry\";\r\nimport { Gradient, GradientStop, gradientColorForValue } from \"./gradients\";\r\nimport { LegendSettings, placeLegend } from \"./legend\";\r\n\r\nexport function renderWeathermapInto(\r\n    elementCreator: SVGElementCreatorDOM, container: Node, config: WeathermapConfig, currentValues: MetricValueMap,\r\n    linkResolver: ((linkSettings: ObjectLinkSettings) => string|null)|null|undefined, addViewBox: boolean = false\r\n): SVGSVGElement {\r\n    // sort gradient stops\r\n    let sortedStops: GradientStop[] = config.gradient.stops\r\n        .slice()\r\n        .sort((l, r) => l.position - r.position);\r\n    let sortedGradient: Gradient = {\r\n        type: config.gradient.type,\r\n        stops: sortedStops\r\n    };\r\n\r\n    let state = new WeathermapRendererState(elementCreator, config, sortedGradient, currentValues);\r\n\r\n    initializeSVG(state, container, addViewBox);\r\n\r\n    // resolve links\r\n    if (linkResolver != null) {\r\n        state.nodeLinkUriBase = linkResolver(config.link.node);\r\n        state.edgeLinkUriBase = linkResolver(config.link.edge);\r\n    }\r\n\r\n    // emplacement\r\n    placeNodes(state);\r\n    placeEdges(state);\r\n    placeLabels(state);\r\n    placeLegend(state.make, config.legend, state.legendGroup!, state.defs!, sortedGradient, `${config.id}`);\r\n\r\n    return state.svg!;\r\n}\r\n\r\nfunction initializeSVG(state: WeathermapRendererState, container: Node, addViewBox: boolean = false): void {\r\n    // add SVG\r\n    state.svg = state.make.svg();\r\n    modifyStyle(state.svg, {\r\n        \"width\": `${state.config.canvasSize.width}px`,\r\n        \"height\": `${state.config.canvasSize.height}px`,\r\n    });\r\n    if (addViewBox) {\r\n        state.svg.setAttribute(\"viewBox\", `0 0 ${state.config.canvasSize.width} ${state.config.canvasSize.height}`);\r\n    }\r\n    container.appendChild(state.svg);\r\n\r\n    state.defs = state.make.defs();\r\n    state.svg.appendChild(state.defs);\r\n\r\n    state.legendGroup = state.make.g();\r\n    state.legendGroup.setAttribute(\"class\", \"legend\");\r\n    state.svg.appendChild(state.legendGroup);\r\n\r\n    state.edgeGroup = state.make.g();\r\n    state.edgeGroup.setAttribute(\"class\", \"edges\");\r\n    state.svg.appendChild(state.edgeGroup);\r\n\r\n    state.nodeGroup = state.make.g();\r\n    state.nodeGroup.setAttribute(\"class\", \"nodes\");\r\n    state.svg.appendChild(state.nodeGroup);\r\n\r\n    state.labelGroup = state.make.g();\r\n    state.labelGroup.setAttribute(\"class\", \"labels\");\r\n    state.svg.appendChild(state.labelGroup);\r\n}\r\n\r\nfunction placeNodes(state: WeathermapRendererState): void {\r\n    for (let node of state.config.weathermapNodes) {\r\n        state.nodeLabelToNode[node.label] = node;\r\n\r\n        let singleNodeGroup: SVGGElement = state.make.g();\r\n        maybeWrapIntoLink(state.make, state.nodeGroup!, singleNodeGroup, state.nodeLinkUriBase, node.linkParams);\r\n\r\n        let rect: SVGRectElement = state.make.rect();\r\n        singleNodeGroup.appendChild(rect);\r\n\r\n        setRectangleDimensions(rect, node.x, node.y, node.width, node.height);\r\n        modifyStyle(rect, {\r\n            \"stroke\": \"gray\",\r\n            \"stroke-width\": \"1px\",\r\n        });\r\n\r\n        let text: SVGTextElement = state.make.text();\r\n        singleNodeGroup.appendChild(text);\r\n\r\n        text.setAttribute(\"x\", `${(+node.x) + (+state.config.textOffsets.left)}`);\r\n        text.setAttribute(\"y\", `${(+node.y) + (+node.height) - state.config.textOffsets.bottom}`);\r\n        if (state.config.showNumbers && node.metricName != null) {\r\n            let value: string = (node.metricName in state.currentValues)\r\n                ? `${state.currentValues[node.metricName]}`\r\n                : \"?\"\r\n            ;\r\n            text.textContent = `${node.label} (${value})`;\r\n        } else {\r\n            text.textContent = node.label;\r\n        }\r\n\r\n        if (!node.metricName) {\r\n            modifyStyle(rect, {\r\n                \"fill\": \"silver\",\r\n                \"stroke-dasharray\": state.config.unmeasuredDashArray,\r\n            });\r\n        } else if (node.metricName in state.currentValues) {\r\n            // color node by metric\r\n            let currentValue: number = state.currentValues[node.metricName];\r\n            modifyStyle(rect, {\r\n                \"fill\": gradientColorForValue(state.sortedGradient, \"fillColor\", currentValue),\r\n            });\r\n        } else {\r\n            // no data\r\n            modifyStyle(text, {\r\n                \"fill\": \"white\",\r\n            });\r\n            modifyStyle(rect, {\r\n                \"fill\": \"black\",\r\n                \"stroke-dasharray\": state.config.noValueDashArray,\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nfunction placeEdges(state: WeathermapRendererState): void {\r\n    // place edges\r\n    for (let edge of state.config.weathermapEdges) {\r\n        let node1: WeathermapNode = state.nodeLabelToNode[edge.node1];\r\n        let node2: WeathermapNode = state.nodeLabelToNode[edge.node2];\r\n        if (!node1 || !node2) {\r\n            // TODO: output error\r\n            continue;\r\n        }\r\n\r\n        let singleEdgeGroup: SVGGElement = state.make.g();\r\n        maybeWrapIntoLink(state.make, state.edgeGroup!, singleEdgeGroup, state.edgeLinkUriBase, edge.linkParams);\r\n\r\n        let n1Center: Point2D = {\r\n            x: (+node1.x) + ((+node1.width) / 2),\r\n            y: (+node1.y) + ((+node1.height) / 2)\r\n        };\r\n        let n2Center: Point2D = {\r\n            x: (+node2.x) + ((+node2.width) / 2),\r\n            y: (+node2.y) + ((+node2.height) / 2)\r\n        };\r\n\r\n        // calculate bend (control points)\r\n        let control1: Point2D|null = null;\r\n        let control2: Point2D|null = null;\r\n        if (edge.bendDirection && edge.bendMagnitude) {\r\n            // warning: screen coordinates (flipped Y axis)!\r\n            let n1N2Angle: number = Math.atan2(n1Center.y - n2Center.y, n2Center.x - n1Center.x);\r\n            let n2N1Angle: number = Math.atan2(n2Center.y - n1Center.y, n1Center.x - n2Center.x);\r\n\r\n            let n1N2BendAngle: number = normalizeAngle(n1N2Angle + deg2rad(edge.bendDirection));\r\n            let n2N1BendAngle: number = normalizeAngle(n2N1Angle - deg2rad(edge.bendDirection));\r\n\r\n            let control1Offset: Point2D = polarToCartesian(n1N2BendAngle, edge.bendMagnitude);\r\n            let control2Offset: Point2D = polarToCartesian(n2N1BendAngle, edge.bendMagnitude);\r\n\r\n            control1 = {\r\n                x: (+n1Center.x) + control1Offset.x,\r\n                y: (+n1Center.y) - control1Offset.y\r\n            };\r\n            control2 = {\r\n                x: (+n2Center.x) + control2Offset.x,\r\n                y: (+n2Center.y) - control2Offset.y\r\n            };\r\n        }\r\n\r\n        if (edge.metric2Name) {\r\n            // two metrics are twice the fun\r\n            let\r\n                [, point1COut, point2CIn, point2, point2COut, point3CIn,]\r\n            =\r\n                halveCubicBezier(n1Center, control1, control2, n2Center)\r\n            ;\r\n\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                n1Center, point1COut, point2CIn, point2,\r\n                edge.metricName, edge.styleName,\r\n                `${edge.node1} \\u2192 ${edge.node2}`\r\n            );\r\n\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                point2, point2COut, point3CIn, n2Center,\r\n                edge.metric2Name, edge.styleName,\r\n                `${edge.node2} \\u2192 ${edge.node1}`\r\n            );\r\n        } else {\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                n1Center, control1, control2, n2Center,\r\n                edge.metricName, edge.styleName,\r\n                `${edge.node1} \\u2194 ${edge.node2}`\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nfunction placeLabels(state: WeathermapRendererState): void {\r\n    for (let label of state.config.weathermapLabels) {\r\n        let singleLabelGroup: SVGGElement = state.make.g();\r\n        state.labelGroup!.appendChild(singleLabelGroup);\r\n\r\n        let text: SVGTextElement = state.make.text();\r\n        singleLabelGroup.appendChild(text);\r\n\r\n        text.setAttribute(\"x\", `${+label.x}`);\r\n        text.setAttribute(\"y\", `${+label.y}`);\r\n        text.textContent = label.label;\r\n    }\r\n}\r\n\r\nfunction makeAndPlaceEdge(\r\n    state: WeathermapRendererState, singleEdgeGroup: SVGGElement, start: Point2D, control1: Point2D|null,\r\n    control2: Point2D|null, end: Point2D, metricName: string|null|undefined, edgeStyleName: string|null|undefined,\r\n    title: string|null|undefined\r\n): void {\r\n    let strokeWidths: number[] = [state.config.strokeWidth];\r\n    let edgeStyle: WeathermapStyle|null = getWeathermapStyle(state, edgeStyleName);\r\n    if (edgeStyle && edgeStyle.strokeWidthArray) {\r\n        let pieces: string[] = edgeStyle.strokeWidthArray.split(/[ ,]+/);\r\n        strokeWidths = pieces.map(p => Number.parseFloat(p));\r\n    }\r\n\r\n    if (strokeWidths.length % 2 !== 1) {\r\n        // like stroke-dasharray, double the elements\r\n        strokeWidths.push(...strokeWidths);\r\n    }\r\n\r\n    let offsetUnitVector: Point2D = {x: 0, y: 0};\r\n    if (strokeWidths.length > 1) {\r\n        // calculate an actual offset vector\r\n\r\n        // get the direction\r\n        let direction: Point2D = {\r\n            x: start.x - end.x,\r\n            y: start.y - end.y\r\n        };\r\n\r\n        // rotate 90°; that's the offset vector\r\n        let offsetVector: Point2D = {\r\n            x: direction.y,\r\n            y: -direction.x\r\n        };\r\n\r\n        // calculate unit vector\r\n        offsetUnitVector = unitVector(offsetVector);\r\n    }\r\n\r\n    let multistrokeGroup: SVGGElement = state.make.g();\r\n    singleEdgeGroup.appendChild(multistrokeGroup);\r\n    modifyStyle(multistrokeGroup, {\r\n        \"fill\": \"none\",\r\n    });\r\n\r\n    if (title) {\r\n        let titleElem: SVGTitleElement = state.make.title();\r\n        multistrokeGroup.appendChild(titleElem);\r\n        titleElem.textContent = title;\r\n    }\r\n\r\n    if (metricName != null && metricName in state.currentValues) {\r\n        let currentValue: number = state.currentValues[metricName];\r\n        modifyStyle(multistrokeGroup, {\r\n            \"stroke\": gradientColorForValue(state.sortedGradient, \"strokeColor\", currentValue)\r\n        });\r\n        modifyApplyingWeathermapStyle(state, multistrokeGroup, edgeStyle);\r\n    } else {\r\n        modifyStyle(multistrokeGroup, {\r\n            \"stroke\": \"black\",\r\n            \"stroke-dasharray\": state.config.noValueDashArray\r\n        });\r\n    }\r\n\r\n    let totalStrokeWidth: number = strokeWidths.reduce((acc, cur) => acc + cur, 0);\r\n    let currentOffset: number = -totalStrokeWidth/2.0;\r\n    let isSpacing: boolean = true;\r\n    for (let strokeWidth of strokeWidths) {\r\n        isSpacing = !isSpacing;\r\n        if (isSpacing) {\r\n            currentOffset += strokeWidth;\r\n            continue;\r\n        }\r\n\r\n        // calculate offset\r\n        let xOffset: number = offsetUnitVector.x * (currentOffset + strokeWidth/2.0);\r\n        let yOffset: number = offsetUnitVector.y * (currentOffset + strokeWidth/2.0);\r\n\r\n        let strokeStart: Point2D = {\r\n            x: start.x + xOffset,\r\n            y: start.y + yOffset,\r\n        };\r\n        let strokeControl1: Point2D|null = (control1 == null) ? null : {\r\n            x: control1.x + xOffset,\r\n            y: control1.y + yOffset,\r\n        };\r\n        let strokeControl2: Point2D|null = (control2 == null) ? null : {\r\n            x: control2.x + xOffset,\r\n            y: control2.y + yOffset,\r\n        };\r\n        let strokeEnd: Point2D = {\r\n            x: end.x + xOffset,\r\n            y: end.y + yOffset,\r\n        };\r\n\r\n        // make the path\r\n        let path: SVGPathElement = state.make.path();\r\n        multistrokeGroup.appendChild(path);\r\n        if (strokeControl1 == null || strokeControl2 == null) {\r\n            path.setAttribute(\"d\",\r\n                `M ${strokeStart.x},${strokeStart.y} ` +\r\n                `L ${strokeEnd.x},${strokeEnd.y}`\r\n            );\r\n        } else {\r\n            path.setAttribute(\"d\",\r\n                `M ${strokeStart.x},${strokeStart.y} ` +\r\n                `C ${strokeControl1.x},${strokeControl1.y},${strokeControl2.x},${strokeControl2.y},${strokeEnd.x},${strokeEnd.y}`\r\n            );\r\n        }\r\n\r\n        // apply the specific stroke width\r\n        modifyStyle(path, {\r\n            \"stroke-width\": `${strokeWidth}`,\r\n        });\r\n\r\n        currentOffset += strokeWidth;\r\n    }\r\n\r\n    if (state.config.showNumbers) {\r\n        let midpoint: Point2D = halveCubicBezier(start, control1, control2, end)[3];\r\n        let valueString: string = (metricName != null && metricName in state.currentValues)\r\n            ? state.currentValues[metricName].toFixed(2)\r\n            : \"?\"\r\n        ;\r\n        let text: SVGTextElement = state.make.text();\r\n        singleEdgeGroup.appendChild(text);\r\n        text.setAttribute(\"x\", `${midpoint.x}`);\r\n        text.setAttribute(\"y\", `${midpoint.y}`);\r\n        text.textContent = valueString;\r\n    }\r\n}\r\n\r\nfunction maybeWrapIntoLink(\r\n    svgMake: SVGElementCreator, upperGroup: SVGGElement, singleObjectGroup: SVGGElement,\r\n    linkUriBase: string|null|undefined, objLinkParams: string|null|undefined\r\n): void {\r\n    if (linkUriBase != null) {\r\n        let objLinkUri: string = linkUriBase;\r\n        if (objLinkParams != null) {\r\n            objLinkUri += (objLinkUri.indexOf(\"?\") === -1)\r\n                ? \"?\"\r\n                : \"&\";\r\n\r\n            objLinkUri += objLinkParams;\r\n        }\r\n\r\n        let aElement: SVGAElement = svgMake.a();\r\n        upperGroup.appendChild(aElement);\r\n        aElement.setAttributeNS(xlinkNamespace, \"href\", objLinkUri);\r\n\r\n        aElement.appendChild(singleObjectGroup);\r\n    } else {\r\n        upperGroup.appendChild(singleObjectGroup);\r\n    }\r\n}\r\n\r\nexport function setRectangleDimensions(\r\n    element: SVGRectElement, x: number|string, y: number|string, width: number|string, height: number|string\r\n): void {\r\n    element.setAttribute(\"x\", `${x}`);\r\n    element.setAttribute(\"y\", `${y}`);\r\n    element.setAttribute(\"width\", `${width}`);\r\n    element.setAttribute(\"height\", `${height}`);\r\n}\r\n\r\nfunction modifyStyle(element: Element, newValues: object): void {\r\n    // parse style\r\n    let assembledStyle: StringMapping<string> = {};\r\n    if (element.hasAttribute(\"style\")) {\r\n        let styleVal: string|null = element.getAttribute(\"style\");\r\n        if (styleVal != null) {\r\n            for (let chunk of styleVal.split(\";\")) {\r\n                let index: number = chunk.indexOf(\":\");\r\n                if (index === -1) {\r\n                    continue;\r\n                }\r\n                let key: string = chunk.substr(0, index);\r\n                let value: string = chunk.substr(index + 1);\r\n                assembledStyle[key] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let key in newValues) {\r\n        if (newValues.hasOwnProperty(key)) {\r\n            if (newValues[key] === null) {\r\n                delete assembledStyle[key];\r\n            } else {\r\n                assembledStyle[key] = newValues[key];\r\n            }\r\n        }\r\n    }\r\n\r\n    let keyValuePairs: string[] = [];\r\n    for (let key in assembledStyle) {\r\n        if (assembledStyle.hasOwnProperty(key)) {\r\n            keyValuePairs.push(`${key}:${assembledStyle[key]}`);\r\n        }\r\n    }\r\n\r\n    let keyValueString: string = keyValuePairs.join(\";\");\r\n    element.setAttribute(\"style\", keyValueString);\r\n}\r\n\r\nfunction getWeathermapStyle(\r\n    state: WeathermapRendererState, styleName: string|null|undefined\r\n): WeathermapStyle|null {\r\n    if (!styleName) {\r\n        return null;\r\n    }\r\n\r\n    let style: WeathermapStyle|undefined = state.styleMap[styleName];\r\n    if (!style) {\r\n        return null;\r\n    }\r\n    return style;\r\n}\r\n\r\nfunction modifyApplyingWeathermapStyle(\r\n    state: WeathermapRendererState, element: Element, style: WeathermapStyle|null\r\n): void {\r\n    if (!style) {\r\n        return;\r\n    }\r\n\r\n    let styleProps: StringMapping<string> = {};\r\n    if (style.dashArray) {\r\n        styleProps[\"stroke-dasharray\"] = style.dashArray;\r\n    }\r\n    // style.strokeWidthArray is handled beforehand\r\n\r\n    modifyStyle(element, styleProps);\r\n}\r\n\r\n\r\nexport class WeathermapRendererState {\r\n    make: SVGElementCreator;\r\n    config: WeathermapConfig;\r\n    sortedGradient: Gradient;\r\n    currentValues: MetricValueMap;\r\n    nodeLabelToNode: LabelToNodeMap;\r\n    nodeLinkUriBase: string|null;\r\n    edgeLinkUriBase: string|null;\r\n    svg: SVGSVGElement|null;\r\n    defs: SVGDefsElement|null;\r\n    edgeGroup: SVGGElement|null;\r\n    nodeGroup: SVGGElement|null;\r\n    labelGroup: SVGGElement|null;\r\n    legendGroup: SVGGElement|null;\r\n    styleMap: NameToStyleMap;\r\n\r\n    constructor(\r\n        domCreator: SVGElementCreatorDOM, config: WeathermapConfig, sortedGradient: Gradient, currentValues: MetricValueMap\r\n    ) {\r\n        this.make = new SVGElementCreator(domCreator);\r\n        this.config = config;\r\n        this.sortedGradient = sortedGradient;\r\n        this.currentValues = currentValues;\r\n        this.nodeLabelToNode = {};\r\n        this.nodeLinkUriBase = null;\r\n        this.edgeLinkUriBase = null;\r\n        this.svg = null;\r\n        this.defs = null;\r\n        this.edgeGroup = null;\r\n        this.nodeGroup = null;\r\n        this.labelGroup = null;\r\n        this.legendGroup = null;\r\n\r\n        this.styleMap = {};\r\n        if (config.weathermapStyles) {\r\n            for (let style of config.weathermapStyles) {\r\n                this.styleMap[style.name] = style;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class SVGElementCreator {\r\n    maker: SVGElementCreatorDOM;\r\n\r\n    constructor(maker: SVGElementCreatorDOM) { this.maker = maker; }\r\n\r\n    a() { return <SVGAElement>this.maker.createElementNS(svgNamespace, \"a\"); }\r\n    defs() { return <SVGDefsElement>this.maker.createElementNS(svgNamespace, \"defs\"); }\r\n    g() { return <SVGGElement>this.maker.createElementNS(svgNamespace, \"g\"); }\r\n    linearGradient() { return <SVGLinearGradientElement>this.maker.createElementNS(svgNamespace, \"linearGradient\"); }\r\n    path() { return <SVGPathElement>this.maker.createElementNS(svgNamespace, \"path\"); }\r\n    rect() { return <SVGRectElement>this.maker.createElementNS(svgNamespace, \"rect\"); }\r\n    stop() { return <SVGStopElement>this.maker.createElementNS(svgNamespace, \"stop\"); }\r\n    svg() { return <SVGSVGElement>this.maker.createElementNS(svgNamespace, \"svg\"); }\r\n    text() { return <SVGTextElement>this.maker.createElementNS(svgNamespace, \"text\"); }\r\n    title() { return <SVGTitleElement>this.maker.createElementNS(svgNamespace, \"title\"); }\r\n}\r\n\r\nexport interface SVGElementCreatorDOM {\r\n    createElementNS(namespaceURI: string, qualifiedName: string): Element;\r\n}\r\n\r\ninterface PositionableTextElement {\r\n    label: string;\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport interface WeathermapNode extends PositionableTextElement {\r\n    width: number;\r\n    height: number;\r\n    metricName?: string|null;\r\n    linkParams?: string;\r\n}\r\n\r\nexport interface WeathermapEdge {\r\n    node1: string;\r\n    node2: string;\r\n    bendDirection?: number;\r\n    bendMagnitude?: number;\r\n    metricName?: string;\r\n    metric2Name?: string|null;\r\n    linkParams?: string;\r\n    styleName?: string;\r\n}\r\n\r\nexport interface WeathermapLabel extends PositionableTextElement {\r\n}\r\n\r\nexport interface WeathermapStyle {\r\n    name: string;\r\n    strokeWidthArray?: string;\r\n    dashArray?: string;\r\n}\r\n\r\ninterface LinkSettings {\r\n    node: ObjectLinkSettings;\r\n    edge: ObjectLinkSettings;\r\n}\r\n\r\nexport interface StringMapping<V> {\r\n    [key: string]: V;\r\n}\r\n\r\nexport type LabelToNodeMap = StringMapping<WeathermapNode>;\r\nexport type MetricValueMap = StringMapping<number>;\r\nexport type NameToStyleMap = StringMapping<WeathermapStyle>;\r\n\r\nexport interface ObjectLinkSettings {\r\n    type: \"none\"|\"dashboard\"|\"absolute\";\r\n    dashboard: string|null;\r\n    dashUri: string|null;\r\n    absoluteUri: string|null;\r\n}\r\n\r\nexport interface WeathermapDefaultConfig {\r\n    weathermapEdges: WeathermapEdge[];\r\n    weathermapNodes: WeathermapNode[];\r\n    weathermapLabels: WeathermapLabel[];\r\n    weathermapStyles: WeathermapStyle[];\r\n    canvasSize: { width: number; height: number; };\r\n    textOffsets: { left: number; bottom: number; };\r\n    showNumbers: boolean;\r\n    valueName: \"max\"|\"min\"|\"avg\"|\"current\"|\"total\";\r\n    nullPointMode: \"connected\"|\"null\"|\"null as zero\";\r\n    strokeWidth: number;\r\n    gradient: Gradient;\r\n    legend: LegendSettings;\r\n    link: LinkSettings;\r\n    noValueDashArray: string;\r\n    unmeasuredDashArray: string;\r\n}\r\n\r\nexport interface WeathermapConfig extends WeathermapDefaultConfig {\r\n    id: number;\r\n}\r\n","import { WeathermapCtrl } from \"./weathermapControl\";\r\n\r\nexport {\r\n    WeathermapCtrl as PanelCtrl\r\n};\r\n","import { MetricsPanelCtrl } from 'grafana/app/plugins/sdk';\r\nimport { editorPath, nodeEditorPath, edgeEditorPath, labelEditorPath, styleEditorPath } from \"./properties\";\r\nimport {\r\n    renderWeathermapInto,\r\n    WeathermapConfig,\r\n    WeathermapDefaultConfig,\r\n    WeathermapNode,\r\n    WeathermapEdge,\r\n    WeathermapLabel,\r\n    WeathermapStyle,\r\n    ObjectLinkSettings,\r\n    StringMapping\r\n} from \"./svg-weathermap/weathermap\";\r\nimport {\r\n    GradientStop\r\n} from \"./svg-weathermap/gradients\";\r\nimport _ from \"lodash\";\r\nimport TimeSeries from \"grafana/app/core/time_series2\";\r\n\r\nconst panelDefaults: WeathermapDefaultConfig = {\r\n    // data\r\n    weathermapNodes: [],\r\n    weathermapEdges: [],\r\n    weathermapLabels: [],\r\n    weathermapStyles: [],\r\n    canvasSize: {\r\n        width: 800,\r\n        height: 600\r\n    },\r\n    textOffsets: {\r\n        left: 5,\r\n        bottom: 5\r\n    },\r\n    showNumbers: false,\r\n    valueName: \"max\",\r\n    nullPointMode: \"connected\",\r\n    strokeWidth: 1,\r\n    gradient: {\r\n        type: \"steps\",\r\n        stops: []\r\n    },\r\n    legend: {\r\n        type: \"\",\r\n        x: 0,\r\n        y: 0,\r\n        length: 100,\r\n        width: 5\r\n    },\r\n    link: {\r\n        node: {\r\n            type: \"none\",\r\n            absoluteUri: null,\r\n            dashboard: null,\r\n            dashUri: null\r\n        },\r\n        edge: {\r\n            type: \"none\",\r\n            absoluteUri: null,\r\n            dashboard: null,\r\n            dashUri: null\r\n        }\r\n    },\r\n    noValueDashArray: \"4 4\",\r\n    unmeasuredDashArray: \"4 2\",\r\n};\r\n\r\nexport class WeathermapCtrl extends MetricsPanelCtrl {\r\n    static templateUrl: string;\r\n    currentValues: {[key: string]: number;};\r\n    currentSeries: object;\r\n\r\n    panel: WeathermapConfig;\r\n\r\n    searchDashboards: (queryStr: string, callback: (matches: string[]) => any) => void;\r\n\r\n    /** @ngInject **/\r\n    constructor($scope: any, $injector: any, private backendSrv: any) {\r\n        super($scope, $injector);\r\n        _.defaultsDeep(this.panel, panelDefaults);\r\n\r\n        this.currentValues = {};\r\n\r\n        this.events.on(\"init-edit-mode\", this.onInitEditMode.bind(this));\r\n        this.events.on(\"data-received\", this.onDataReceived.bind(this));\r\n        this.events.on(\"data-snapshot-load\", this.onDataSnapshotLoad.bind(this));\r\n\r\n        this.searchDashboards = function (queryStr: string, callback: (matches: string[]) => any): void {\r\n            backendSrv.search({query: queryStr}).then(hits => {\r\n                let dashboards: any[] = _.map(hits, dash => dash.title);\r\n                callback(dashboards);\r\n            });\r\n        };\r\n    }\r\n\r\n    onInitEditMode(): void {\r\n        this.addEditorTab(\"Options\", editorPath, 2);\r\n        this.addEditorTab(\"Nodes\", nodeEditorPath, 3);\r\n        this.addEditorTab(\"Edges\", edgeEditorPath, 4);\r\n        this.addEditorTab(\"Labels\", labelEditorPath, 5);\r\n        this.addEditorTab(\"Styles\", styleEditorPath, 6);\r\n    }\r\n\r\n    onDataReceived(dataList: any): void {\r\n        this.currentSeries = dataList.map(this.seriesHandler.bind(this));\r\n        this.currentValues = this.parseSeries(this.currentSeries);\r\n\r\n        this.render();\r\n    }\r\n\r\n    seriesHandler(seriesData: any): TimeSeries {\r\n        let series = new TimeSeries({\r\n            datapoints: seriesData.datapoints,\r\n            alias: seriesData.target\r\n        });\r\n        series.getFlotPairs(this.panel.nullPointMode);\r\n        return series;\r\n    }\r\n\r\n    parseSeries(series: any): StringMapping<number> {\r\n        let targetToValue: StringMapping<number> = {};\r\n        for (let ser of series) {\r\n            targetToValue[ser.alias] = ser.stats[this.panel.valueName];\r\n        }\r\n        return targetToValue;\r\n    }\r\n\r\n    onDataSnapshotLoad(snapshotData: any): void {\r\n        this.onDataReceived(snapshotData);\r\n    }\r\n\r\n    addWeathermapNode(node?: WeathermapNode): void {\r\n        this.panel.weathermapNodes.push(node || <WeathermapNode>{});\r\n    }\r\n    removeWeathermapNode(node: WeathermapNode): void {\r\n        this.panel.weathermapNodes = _.without(this.panel.weathermapNodes, node);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapEdge(edge?: WeathermapEdge): void {\r\n        this.panel.weathermapEdges.push(edge || <WeathermapEdge>{});\r\n    }\r\n    removeWeathermapEdge(edge: WeathermapEdge): void {\r\n        this.panel.weathermapEdges = _.without(this.panel.weathermapEdges, edge);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapLabel(label?: WeathermapLabel): void {\r\n        this.panel.weathermapLabels.push(label || <WeathermapLabel>{});\r\n    }\r\n    removeWeathermapLabel(label: WeathermapLabel): void {\r\n        this.panel.weathermapLabels = _.without(this.panel.weathermapLabels, label);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapStyle(style?: WeathermapStyle): void {\r\n        this.panel.weathermapStyles.push(style || <WeathermapStyle>{});\r\n    }\r\n    removeWeathermapStyle(style: WeathermapStyle): void {\r\n        this.panel.weathermapStyles = _.without(this.panel.weathermapStyles, style);\r\n        this.refresh();\r\n    }\r\n\r\n    addGradientStop(stop?: GradientStop): void {\r\n        this.panel.gradient.stops.push(stop || <GradientStop>{});\r\n    }\r\n    onGradientStopStrokeColorChange(stopIndex: number): (color: string) => void {\r\n        return (color: string) => {\r\n            this.panel.gradient.stops[stopIndex].strokeColor = color;\r\n            this.refresh();\r\n        };\r\n    }\r\n    onGradientStopFillColorChange(stopIndex: number): (color: string) => void {\r\n        return (color: string) => {\r\n            this.panel.gradient.stops[stopIndex].fillColor = color;\r\n            this.refresh();\r\n        };\r\n    }\r\n    removeGradientStop(stop: GradientStop): void {\r\n        this.panel.gradient.stops = _.without(this.panel.gradient.stops, stop);\r\n        this.refresh();\r\n    }\r\n\r\n    dashboardChanged(link: ObjectLinkSettings): void {\r\n        this.backendSrv.search({query: link.dashboard}).then((hits) => {\r\n            let dashboard: any = _.find(hits, {title: link.dashboard});\r\n            if (dashboard) {\r\n                link.dashUri = dashboard.uri;\r\n            }\r\n        });\r\n    }\r\n\r\n    link(_scope: any, elems: HTMLElement[], _attrs: any, ctrl: any): void {\r\n        this.events.on(\"render\", () => this.renderThat(elems[0], ctrl));\r\n    }\r\n\r\n    renderThat(topElem: HTMLElement, _ctrl: any): void {\r\n        // find weathermap div\r\n        let elem: Element|null = topElem.querySelector(\"div.weathermap\");\r\n        if (elem === null) {\r\n            // oh well\r\n            return;\r\n        }\r\n\r\n        // filicide\r\n        while (elem.lastChild) {\r\n            elem.removeChild(elem.lastChild);\r\n        }\r\n\r\n        // do it\r\n        renderWeathermapInto(document, elem, this.panel, this.currentValues, WeathermapCtrl.resolveLink);\r\n    }\r\n\r\n    static resolveLink(objLink: ObjectLinkSettings): string|null {\r\n        if (objLink.type === \"absolute\" && objLink.absoluteUri) {\r\n            return objLink.absoluteUri;\r\n        } else if (objLink.type === \"dashboard\" && objLink.dashUri) {\r\n            let url = new URL(window.location.href);\r\n            let oldParams: StringMapping<string> = getSearchParams(url);\r\n            let params: string[] = [];\r\n\r\n            if (oldParams.from) {\r\n                params.push(`from=${encodeURIComponent(oldParams.from)}`);\r\n            }\r\n\r\n            if (oldParams.to) {\r\n                params.push(`to=${encodeURIComponent(oldParams.to)}`);\r\n            }\r\n\r\n            let paramSuffix: string = \"\";\r\n            if (params.length > 0) {\r\n                paramSuffix = \"?\" + params.join(\"&\");\r\n            }\r\n            return `/dashboard/${objLink.dashUri}${paramSuffix}`;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nWeathermapCtrl.templateUrl = \"partials/module.html\";\r\n\r\nfunction getSearchParams(url: URL): StringMapping<string> {\r\n    let search: string = url.search;\r\n    while (search.startsWith(\"?\")) {\r\n        search = search.substr(1);\r\n    }\r\n\r\n    let params: StringMapping<string> = {};\r\n    if (search.length > 0) {\r\n        let pairs: string[] = search.split(\"&\");\r\n        for (let pair of pairs) {\r\n            let keyValueMatch: RegExpMatchArray|null = pair.match(/^([^=]*)(?:=(.*))?$/);\r\n            if (keyValueMatch === null) {\r\n                continue;\r\n            }\r\n\r\n            let key: string = keyValueMatch[1];\r\n            let value: string = keyValueMatch[2];\r\n            if (key !== undefined && value !== undefined) {\r\n                params[decodeURIComponent(key)] = decodeURIComponent(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return params;\r\n}\r\n","export const\r\n    pluginName: string = \"ravualhemio-weathermap-panel\",\r\n    editorPath: string = `public/plugins/${pluginName}/partials/editor.html`,\r\n    nodeEditorPath: string = `public/plugins/${pluginName}/partials/nodeEditor.html`,\r\n    edgeEditorPath: string = `public/plugins/${pluginName}/partials/edgeEditor.html`,\r\n    labelEditorPath: string = `public/plugins/${pluginName}/partials/labelEditor.html`,\r\n    styleEditorPath: string = `public/plugins/${pluginName}/partials/styleEditor.html`;\r\n","export const svgNamespace: string = \"http://www.w3.org/2000/svg\";\r\nexport const xlinkNamespace: string = \"http://www.w3.org/1999/xlink\";\r\n","export function midpoint(point1: Point2D, point2: Point2D): Point2D {\r\n    return {\r\n        x: (point1.x + point2.x)/2.0,\r\n        y: (point1.y + point2.y)/2.0\r\n    };\r\n}\r\n\r\nexport function halveCubicBezier(\r\n    point1: Point2D, control1: Point2D|null, control2: Point2D|null, point2: Point2D\r\n): [Point2D, Point2D, Point2D, Point2D, Point2D, Point2D, Point2D] {\r\n    if (control1 === null) {\r\n        if (control2 === null) {\r\n            // naïveté!\r\n            let straightMidpoint: Point2D = midpoint(point1, point2);\r\n            return [point1, point1, straightMidpoint, straightMidpoint, straightMidpoint, point2, point2];\r\n        }\r\n\r\n        control1 = point1;\r\n    }\r\n    if (control2 === null) {\r\n        control2 = point2;\r\n    }\r\n\r\n    let m1: Point2D = midpoint(point1, control1);\r\n    let m2: Point2D = midpoint(control1, control2);\r\n    let m3: Point2D = midpoint(control2, point2);\r\n\r\n    let q1: Point2D = midpoint(m1, m2);\r\n    let q2: Point2D = midpoint(m2, m3);\r\n\r\n    let o: Point2D = midpoint(q1, q2);\r\n\r\n    return [point1, m1, q1, o, q2, m3, point2];\r\n}\r\n\r\nexport function polarToCartesian(angleRadians: number|null, length: number|null): Point2D {\r\n    if (angleRadians === null) {\r\n        angleRadians = 0;\r\n    }\r\n    if (length === null) {\r\n        length = 0;\r\n    }\r\n\r\n    return {\r\n        x: length * Math.cos(angleRadians),\r\n        y: length * Math.sin(angleRadians)\r\n    };\r\n}\r\n\r\nexport function normalizeAngle(angleRadians: number): number {\r\n    while (angleRadians <= -Math.PI) {\r\n        angleRadians += 2 * Math.PI;\r\n    }\r\n    while (angleRadians > Math.PI) {\r\n        angleRadians -= 2 * Math.PI;\r\n    }\r\n    return angleRadians;\r\n}\r\n\r\nexport function unitVector(vector: Point2D): Point2D {\r\n    let euclidNorm: number = Math.sqrt(vector.x*vector.x + vector.y*vector.y);\r\n    return {\r\n        x: vector.x / euclidNorm,\r\n        y: vector.y / euclidNorm\r\n    };\r\n}\r\n\r\nexport function deg2rad(angleDegrees: number): number {\r\n    return angleDegrees * Math.PI / 180;\r\n}\r\n\r\nexport function rad2deg(angleRadians: number): number {\r\n    return angleRadians * 180 / Math.PI;\r\n}\r\n\r\nexport interface Point2D {\r\n    x: number;\r\n    y: number;\r\n}\r\n","const emergencyColor: string = \"pink\";\r\n\r\nexport function gradientColorForValue(gradient: Gradient, colorType: keyof GradientStop, value: number): string {\r\n    if (gradient.type === \"linear\") {\r\n        return linearColorForValue(gradient.stops, colorType, value);\r\n    } else if (gradient.type === \"steps\") {\r\n        return stepColorForValue(gradient.stops, colorType, value);\r\n    }\r\n    return emergencyColor;\r\n}\r\n\r\nfunction linearColorForValue(stops: GradientStop[], colorType: keyof GradientStop, value: number): string {\r\n    if (stops.length === 0) {\r\n        return emergencyColor;\r\n    }\r\n\r\n    let lastStop: GradientStop = stops[stops.length-1];\r\n    let r: number = 0.0, g: number = 0.0, b: number = 0.0;\r\n    if (value < stops[0].position) {\r\n        return `${stops[0][colorType]}`;\r\n    } else if (value >= lastStop.position) {\r\n        return `${lastStop[colorType]}`;\r\n    } else {\r\n        let foundMatch: boolean = false;\r\n        for (let i: number = 0; i < stops.length-1; ++i) {\r\n            if (value >= stops[i].position && value < stops[i+1].position) {\r\n                // found!\r\n\r\n                let posFrom: number = stops[i].position;\r\n                let rFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(1, 2), 16);\r\n                let gFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(3, 2), 16);\r\n                let bFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(5, 2), 16);\r\n\r\n                let posTo: number = stops[i+1].position;\r\n                let rTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(1, 2), 16);\r\n                let gTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(3, 2), 16);\r\n                let bTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(5, 2), 16);\r\n\r\n                r = lerp(value, posFrom, posTo, rFrom, rTo);\r\n                g = lerp(value, posFrom, posTo, gFrom, gTo);\r\n                b = lerp(value, posFrom, posTo, bFrom, bTo);\r\n\r\n                foundMatch = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!foundMatch) {\r\n            return emergencyColor;\r\n        }\r\n    }\r\n\r\n    return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;\r\n}\r\n\r\nfunction stepColorForValue(stops: GradientStop[], colorType: keyof GradientStop, value: number): string {\r\n    if (stops.length === 0) {\r\n        return emergencyColor;\r\n    }\r\n\r\n    let lastStop: GradientStop = stops[stops.length-1];\r\n    if (value < stops[0].position) {\r\n        return `${stops[0][colorType]}`;\r\n    } else if (value >= lastStop.position) {\r\n        return `${lastStop[colorType]}`;\r\n    } else {\r\n        for (let i: number = 0; i < stops.length-1; ++i) {\r\n            if (value >= stops[i].position && value < stops[i+1].position) {\r\n                return `${stops[i][colorType]}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    return emergencyColor;\r\n}\r\n\r\nfunction lerp(value: number, sourceMin: number, sourceMax: number, targetMin: number, targetMax: number): number {\r\n    if (targetMin === targetMax) {\r\n        return targetMin;\r\n    }\r\n\r\n    if (value < sourceMin) {\r\n        value = sourceMin;\r\n    }\r\n    if (value > sourceMax) {\r\n        value = sourceMax;\r\n    }\r\n\r\n    let terp: number = (value - sourceMin) / (sourceMax - sourceMin);\r\n    return targetMin + terp * (targetMax - targetMin);\r\n}\r\n\r\n\r\nexport interface GradientStop {\r\n    position: number;\r\n    strokeColor: string;\r\n    fillColor: string;\r\n    showLegendLabel: boolean;\r\n}\r\n\r\nexport interface Gradient {\r\n    type: \"steps\"|\"linear\";\r\n    stops: GradientStop[];\r\n}\r\n","import { Gradient, GradientStop } from \"./gradients\";\r\nimport { SVGElementCreator, setRectangleDimensions } from \"./weathermap\";\r\n\r\nconst legendLength: number = 100;\r\nconst legendWidth: number = 5;\r\n// (let the container apply any transformations)\r\n\r\nexport function placeLegend(\r\n    svgMake: SVGElementCreator, settings: LegendSettings, container: Element, defs: SVGDefsElement, gradient: Gradient,\r\n    weathermapID?: string|null\r\n): void {\r\n    let transform: string = \"\";\r\n\r\n    if (settings.type === \"\") {\r\n        // no legend\r\n        return;\r\n    }\r\n\r\n    // draw stroke-color legend\r\n    let strokeLegendContainer: SVGGElement = svgMake.g();\r\n    container.appendChild(strokeLegendContainer);\r\n    strokeLegendContainer.setAttribute(\"class\", \"stroke-legend\");\r\n    if (settings.type[0] === \"h\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y})`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    } else if (settings.type[0] === \"v\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y + settings.length})`\r\n            + ` rotate(-90)`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    }\r\n    strokeLegendContainer.setAttribute(\"transform\", transform);\r\n    drawLegend(svgMake, gradient, \"strokeColor\", strokeLegendContainer, defs, weathermapID);\r\n\r\n    // draw fill-color legend\r\n    let fillLegendContainer: SVGGElement = svgMake.g();\r\n    container.appendChild(fillLegendContainer);\r\n    strokeLegendContainer.setAttribute(\"class\", \"fill-legend\");\r\n    if (settings.type[0] === \"h\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y + settings.width})`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    } else if (settings.type[0] === \"v\") {\r\n        transform =\r\n            `translate(${settings.x + settings.width} ${settings.y + settings.length})`\r\n            + ` rotate(-90)`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    }\r\n    fillLegendContainer.setAttribute(\"transform\", transform);\r\n    drawLegend(svgMake, gradient, \"fillColor\", fillLegendContainer, defs, weathermapID);\r\n\r\n    // draw legend labels\r\n    placeLabels(svgMake, settings, gradient, container);\r\n}\r\n\r\nfunction drawLegend(\r\n    svgMake: SVGElementCreator, gradient: Gradient, colorType: keyof GradientStop, container: SVGElement,\r\n    defs: SVGDefsElement, weathermapID?: string|null\r\n): void {\r\n    if (gradient.type === \"linear\") {\r\n        let legendGradientName: string = `WeathermapLegendGradient-${colorType}`;\r\n        if (weathermapID != null) {\r\n            legendGradientName = `${legendGradientName}-${weathermapID}`;\r\n        }\r\n\r\n        let svgGrad: SVGLinearGradientElement = svgMake.linearGradient();\r\n        defs.appendChild(svgGrad);\r\n        svgGrad.setAttribute(\"id\", legendGradientName);\r\n\r\n        for (let stop of gradient.stops) {\r\n            let svgStop: SVGStopElement = svgMake.stop();\r\n            svgGrad.appendChild(svgStop);\r\n            svgStop.setAttribute(\"offset\", `${stop.position}%`);\r\n            svgStop.setAttribute(\"stop-color\", `${stop[colorType]}`);\r\n        }\r\n\r\n        let svgRect: SVGRectElement = svgMake.rect();\r\n        container.appendChild(svgRect);\r\n        setRectangleDimensions(svgRect, 0, 0, legendLength, legendWidth);\r\n        svgRect.setAttribute(\"style\", `fill:url(#${legendGradientName})`);\r\n    } else if (gradient.type === \"steps\") {\r\n        for (let i: number = 1; i < gradient.stops.length; ++i) {\r\n            let rect: SVGRectElement = svgMake.rect();\r\n            container.appendChild(rect);\r\n\r\n            setRectangleDimensions(rect,\r\n                gradient.stops[i-1].position,\r\n                0,\r\n                gradient.stops[i].position - gradient.stops[i-1].position,\r\n                legendWidth\r\n            );\r\n            rect.setAttribute(\"style\", `fill:${gradient.stops[i-1][colorType]}`);\r\n        }\r\n        let rect: SVGRectElement = svgMake.rect();\r\n        container.appendChild(rect);\r\n        setRectangleDimensions(rect,\r\n            gradient.stops[gradient.stops.length-1].position,\r\n            0,\r\n            100 - gradient.stops[gradient.stops.length-1].position,\r\n            legendWidth\r\n        );\r\n        rect.setAttribute(\"style\", `fill:${gradient.stops[gradient.stops.length-1][colorType]}`);\r\n    }\r\n}\r\n\r\nfunction placeLabels(svgMake: SVGElementCreator, settings: LegendSettings, gradient: Gradient, container: Element): void {\r\n    if (settings.type === \"\" || settings.type[1] === \"n\") {\r\n        // no labels\r\n        return;\r\n    }\r\n\r\n    for (let stop of gradient.stops) {\r\n        if (!stop.showLegendLabel) {\r\n            continue;\r\n        }\r\n\r\n        let xCoord: number = settings.x;\r\n        let yCoord: number = settings.y;\r\n        let dy: number = 0.0;\r\n        let textAnchor: \"start\"|\"middle\"|\"end\" = \"start\";\r\n\r\n        if (settings.type[0] === \"h\") {\r\n            // horizontal scale\r\n            xCoord += stop.position * settings.length / legendLength;\r\n\r\n            textAnchor = \"middle\";\r\n            if (settings.type === \"hb\") {\r\n                yCoord += 2 * settings.width;\r\n                dy = 1.0;\r\n            }\r\n        } else if (settings.type[0] === \"v\") {\r\n            // vertical scale\r\n            yCoord += settings.length - (stop.position * settings.length / legendLength);\r\n            dy = 0.4;\r\n\r\n            if (settings.type === \"vl\") {\r\n                textAnchor = \"end\";\r\n            } else if (settings.type === \"vr\") {\r\n                textAnchor = \"start\";\r\n                xCoord += 2 * settings.width;\r\n            }\r\n        }\r\n\r\n        let label: SVGTextElement = svgMake.text();\r\n        container.appendChild(label);\r\n        label.setAttribute(\"class\", \"legend-label\");\r\n        label.setAttribute(\"x\", `${xCoord}`);\r\n        label.setAttribute(\"y\", `${yCoord}`);\r\n        label.setAttribute(\"dy\", `${dy}em`);\r\n        label.setAttribute(\"style\", `text-anchor:${textAnchor}`);\r\n        label.textContent = `${stop.position}`;\r\n    }\r\n}\r\n\r\nexport interface LegendSettings {\r\n    type: \"\"|\"hn\"|\"ha\"|\"hb\"|\"vn\"|\"vl\"|\"vr\";\r\n    x: number;\r\n    y: number;\r\n    length: number;\r\n    width: number;\r\n}\r\n"],"sourceRoot":""}