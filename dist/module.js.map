{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"lodash\"","webpack:///external \"app/plugins/sdk\"","webpack:///external \"app/core/time_series2\"","webpack:///./svg-weathermap/constants.ts","webpack:///./svg-weathermap/geometry.ts","webpack:///./svg-weathermap/gradients.ts","webpack:///./svg-weathermap/legend.ts","webpack:///./svg-weathermap/weathermap.ts","webpack:///./weathermapControl.ts","webpack:///./properties.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__2__","svgNamespace","point1","point2","x","y","halveCubicBezier","control1","control2","straightMidpoint","m1","m2","m3","q1","q2","polarToCartesian","angleRadians","length","Math","cos","sin","normalizeAngle","PI","deg2rad","angleDegrees","gradientColorForValue","gradient","colorType","type","stops","lastStop","g","b","position","foundMatch","posFrom","rFrom","Number","parseInt","substr","gFrom","bFrom","posTo","rTo","gTo","bTo","lerp","floor","linearColorForValue","stepColorForValue","sourceMin","sourceMax","targetMin","targetMax","placeLegend","svgMake","settings","container","defs","weathermapID","transform","strokeLegendContainer","appendChild","setAttribute","width","drawLegend","fillLegendContainer","showLegendLabel","xCoord","yCoord","dy","textAnchor","label","text","textContent","placeLabels","legendGradientName","svgGrad","linearGradient","svgStop","stop","svgRect","rect","setRectangleDimensions","renderWeathermapInto","elementCreator","config","currentValues","linkResolver","addViewBox","sortedStops","slice","sort","sortedGradient","state","WeathermapRendererState","svg","make","modifyStyle","canvasSize","height","legendGroup","edgeGroup","nodeGroup","labelGroup","initializeSVG","nodeLinkUriBase","link","node","edgeLinkUriBase","edge","weathermapNodes","nodeLabelToNode","singleNodeGroup","maybeWrapIntoLink","linkParams","textOffsets","left","bottom","showNumbers","metricName","currentValue","noValueDashArray","unmeasuredDashArray","titleElem","title","insertBefore","firstChild","toFixed","placeNodes","weathermapEdges","node1","node2","singleEdgeGroup","n1Center","n2Center","bendDirection","bendMagnitude","n1N2Angle","atan2","n2N1Angle","n1N2BendAngle","n2N1BendAngle","control1Offset","control2Offset","metric2Name","point1COut","point2CIn","point2COut","point3CIn","makeAndPlaceEdge","styleName","placeEdges","weathermapLabels","singleLabelGroup","legend","id","start","end","edgeStyleName","strokeWidths","strokeWidth","edgeStyle","style","styleMap","getWeathermapStyle","strokeWidthArray","split","map","parseFloat","push","vector","euclidNorm","offsetUnitVector","direction","sqrt","multistrokeGroup","element","styleProps","dashArray","modifyApplyingWeathermapStyle","currentOffset","reduce","acc","cur","isSpacing","xOffset","yOffset","strokeStart","strokeControl1","strokeControl2","strokeEnd","path","midpoint","valueString","upperGroup","singleObjectGroup","linkUriBase","objLinkParams","objLinkUri","indexOf","aElement","a","setAttributeNS","newValues","assembledStyle","hasAttribute","styleVal","getAttribute","chunk","index","keyValuePairs","keyValueString","join","domCreator","this","weathermapStyles","maker","createElementNS","panelDefaults","valueName","nullPointMode","absoluteUri","dashboard","dashUri","$scope","$injector","backendSrv","defaultsDeep","panel","events","on","onInitEditMode","onDataReceived","onDataSnapshotLoad","searchDashboards","queryStr","callback","search","query","then","hits","dashboards","dash","addEditorTab","dataList","currentSeries","seriesHandler","parseSeries","render","seriesData","series","datapoints","alias","target","getFlotPairs","targetToValue","ser","stats","snapshotData","addWeathermapNode","removeWeathermapNode","without","refresh","addWeathermapEdge","removeWeathermapEdge","addWeathermapLabel","removeWeathermapLabel","addWeathermapStyle","removeWeathermapStyle","addGradientStop","onGradientStopStrokeColorChange","stopIndex","color","strokeColor","onGradientStopFillColorChange","fillColor","removeGradientStop","dashboardChanged","find","uri","_scope","elems","_attrs","ctrl","renderThat","topElem","_ctrl","elem","querySelector","lastChild","removeChild","document","WeathermapCtrl","resolveLink","objLink","oldParams","url","startsWith","params","pairs","keyValueMatch","match","undefined","decodeURIComponent","getSearchParams","URL","window","location","href","from","encodeURIComponent","to","paramSuffix","templateUrl"],"mappings":"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","file":"module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","export const svgNamespace: string = \"http://www.w3.org/2000/svg\";\r\nexport const xlinkNamespace: string = \"http://www.w3.org/1999/xlink\";\r\n","export function midpoint(point1: Point2D, point2: Point2D): Point2D {\r\n    return {\r\n        x: (point1.x + point2.x)/2.0,\r\n        y: (point1.y + point2.y)/2.0\r\n    };\r\n}\r\n\r\nexport function halveCubicBezier(\r\n    point1: Point2D, control1: Point2D|null, control2: Point2D|null, point2: Point2D\r\n): [Point2D, Point2D, Point2D, Point2D, Point2D, Point2D, Point2D] {\r\n    if (control1 === null) {\r\n        if (control2 === null) {\r\n            // naïveté!\r\n            let straightMidpoint: Point2D = midpoint(point1, point2);\r\n            return [point1, point1, straightMidpoint, straightMidpoint, straightMidpoint, point2, point2];\r\n        }\r\n\r\n        control1 = point1;\r\n    }\r\n    if (control2 === null) {\r\n        control2 = point2;\r\n    }\r\n\r\n    let m1: Point2D = midpoint(point1, control1);\r\n    let m2: Point2D = midpoint(control1, control2);\r\n    let m3: Point2D = midpoint(control2, point2);\r\n\r\n    let q1: Point2D = midpoint(m1, m2);\r\n    let q2: Point2D = midpoint(m2, m3);\r\n\r\n    let o: Point2D = midpoint(q1, q2);\r\n\r\n    return [point1, m1, q1, o, q2, m3, point2];\r\n}\r\n\r\nexport function polarToCartesian(angleRadians: number|null, length: number|null): Point2D {\r\n    if (angleRadians === null) {\r\n        angleRadians = 0;\r\n    }\r\n    if (length === null) {\r\n        length = 0;\r\n    }\r\n\r\n    return {\r\n        x: length * Math.cos(angleRadians),\r\n        y: length * Math.sin(angleRadians)\r\n    };\r\n}\r\n\r\nexport function normalizeAngle(angleRadians: number): number {\r\n    while (angleRadians <= -Math.PI) {\r\n        angleRadians += 2 * Math.PI;\r\n    }\r\n    while (angleRadians > Math.PI) {\r\n        angleRadians -= 2 * Math.PI;\r\n    }\r\n    return angleRadians;\r\n}\r\n\r\nexport function unitVector(vector: Point2D): Point2D {\r\n    let euclidNorm: number = Math.sqrt(vector.x*vector.x + vector.y*vector.y);\r\n    return {\r\n        x: vector.x / euclidNorm,\r\n        y: vector.y / euclidNorm\r\n    };\r\n}\r\n\r\nexport function deg2rad(angleDegrees: number): number {\r\n    return angleDegrees * Math.PI / 180;\r\n}\r\n\r\nexport function rad2deg(angleRadians: number): number {\r\n    return angleRadians * 180 / Math.PI;\r\n}\r\n\r\nexport interface Point2D {\r\n    x: number;\r\n    y: number;\r\n}\r\n","const emergencyColor: string = \"pink\";\r\n\r\nexport function gradientColorForValue(gradient: Gradient, colorType: keyof GradientStop, value: number): string {\r\n    if (gradient.type === \"linear\") {\r\n        return linearColorForValue(gradient.stops, colorType, value);\r\n    } else if (gradient.type === \"steps\") {\r\n        return stepColorForValue(gradient.stops, colorType, value);\r\n    }\r\n    return emergencyColor;\r\n}\r\n\r\nfunction linearColorForValue(stops: GradientStop[], colorType: keyof GradientStop, value: number): string {\r\n    if (stops.length === 0) {\r\n        return emergencyColor;\r\n    }\r\n\r\n    let lastStop: GradientStop = stops[stops.length-1];\r\n    let r: number = 0.0, g: number = 0.0, b: number = 0.0;\r\n    if (value < stops[0].position) {\r\n        return `${stops[0][colorType]}`;\r\n    } else if (value >= lastStop.position) {\r\n        return `${lastStop[colorType]}`;\r\n    } else {\r\n        let foundMatch: boolean = false;\r\n        for (let i: number = 0; i < stops.length-1; ++i) {\r\n            if (value >= stops[i].position && value < stops[i+1].position) {\r\n                // found!\r\n\r\n                let posFrom: number = stops[i].position;\r\n                let rFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(1, 2), 16);\r\n                let gFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(3, 2), 16);\r\n                let bFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(5, 2), 16);\r\n\r\n                let posTo: number = stops[i+1].position;\r\n                let rTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(1, 2), 16);\r\n                let gTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(3, 2), 16);\r\n                let bTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(5, 2), 16);\r\n\r\n                r = lerp(value, posFrom, posTo, rFrom, rTo);\r\n                g = lerp(value, posFrom, posTo, gFrom, gTo);\r\n                b = lerp(value, posFrom, posTo, bFrom, bTo);\r\n\r\n                foundMatch = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!foundMatch) {\r\n            return emergencyColor;\r\n        }\r\n    }\r\n\r\n    return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;\r\n}\r\n\r\nfunction stepColorForValue(stops: GradientStop[], colorType: keyof GradientStop, value: number): string {\r\n    if (stops.length === 0) {\r\n        return emergencyColor;\r\n    }\r\n\r\n    let lastStop: GradientStop = stops[stops.length-1];\r\n    if (value < stops[0].position) {\r\n        return `${stops[0][colorType]}`;\r\n    } else if (value >= lastStop.position) {\r\n        return `${lastStop[colorType]}`;\r\n    } else {\r\n        for (let i: number = 0; i < stops.length-1; ++i) {\r\n            if (value >= stops[i].position && value < stops[i+1].position) {\r\n                return `${stops[i][colorType]}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    return emergencyColor;\r\n}\r\n\r\nfunction lerp(value: number, sourceMin: number, sourceMax: number, targetMin: number, targetMax: number): number {\r\n    if (targetMin === targetMax) {\r\n        return targetMin;\r\n    }\r\n\r\n    if (value < sourceMin) {\r\n        value = sourceMin;\r\n    }\r\n    if (value > sourceMax) {\r\n        value = sourceMax;\r\n    }\r\n\r\n    let terp: number = (value - sourceMin) / (sourceMax - sourceMin);\r\n    return targetMin + terp * (targetMax - targetMin);\r\n}\r\n\r\n\r\nexport interface GradientStop {\r\n    position: number;\r\n    strokeColor: string;\r\n    fillColor: string;\r\n    showLegendLabel: boolean;\r\n}\r\n\r\nexport interface Gradient {\r\n    type: \"steps\"|\"linear\";\r\n    stops: GradientStop[];\r\n}\r\n","import { Gradient, GradientStop } from \"./gradients\";\r\nimport { SVGElementCreator, setRectangleDimensions } from \"./weathermap\";\r\n\r\nconst legendLength: number = 100;\r\nconst legendWidth: number = 5;\r\n// (let the container apply any transformations)\r\n\r\nexport function placeLegend(\r\n    svgMake: SVGElementCreator, settings: LegendSettings, container: Element, defs: SVGDefsElement, gradient: Gradient,\r\n    weathermapID?: string|null\r\n): void {\r\n    let transform: string = \"\";\r\n\r\n    if (settings.type === \"\") {\r\n        // no legend\r\n        return;\r\n    }\r\n\r\n    // draw stroke-color legend\r\n    let strokeLegendContainer: SVGGElement = svgMake.g();\r\n    container.appendChild(strokeLegendContainer);\r\n    strokeLegendContainer.setAttribute(\"class\", \"stroke-legend\");\r\n    if (settings.type[0] === \"h\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y})`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    } else if (settings.type[0] === \"v\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y + settings.length})`\r\n            + ` rotate(-90)`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    }\r\n    strokeLegendContainer.setAttribute(\"transform\", transform);\r\n    drawLegend(svgMake, gradient, \"strokeColor\", strokeLegendContainer, defs, weathermapID);\r\n\r\n    // draw fill-color legend\r\n    let fillLegendContainer: SVGGElement = svgMake.g();\r\n    container.appendChild(fillLegendContainer);\r\n    strokeLegendContainer.setAttribute(\"class\", \"fill-legend\");\r\n    if (settings.type[0] === \"h\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y + settings.width})`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    } else if (settings.type[0] === \"v\") {\r\n        transform =\r\n            `translate(${settings.x + settings.width} ${settings.y + settings.length})`\r\n            + ` rotate(-90)`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    }\r\n    fillLegendContainer.setAttribute(\"transform\", transform);\r\n    drawLegend(svgMake, gradient, \"fillColor\", fillLegendContainer, defs, weathermapID);\r\n\r\n    // draw legend labels\r\n    placeLabels(svgMake, settings, gradient, container);\r\n}\r\n\r\nfunction drawLegend(\r\n    svgMake: SVGElementCreator, gradient: Gradient, colorType: keyof GradientStop, container: SVGElement,\r\n    defs: SVGDefsElement, weathermapID?: string|null\r\n): void {\r\n    if (gradient.type === \"linear\") {\r\n        let legendGradientName: string = `WeathermapLegendGradient-${colorType}`;\r\n        if (weathermapID != null) {\r\n            legendGradientName = `${legendGradientName}-${weathermapID}`;\r\n        }\r\n\r\n        let svgGrad: SVGLinearGradientElement = svgMake.linearGradient();\r\n        defs.appendChild(svgGrad);\r\n        svgGrad.setAttribute(\"id\", legendGradientName);\r\n\r\n        for (let stop of gradient.stops) {\r\n            let svgStop: SVGStopElement = svgMake.stop();\r\n            svgGrad.appendChild(svgStop);\r\n            svgStop.setAttribute(\"offset\", `${stop.position}%`);\r\n            svgStop.setAttribute(\"stop-color\", `${stop[colorType]}`);\r\n        }\r\n\r\n        let svgRect: SVGRectElement = svgMake.rect();\r\n        container.appendChild(svgRect);\r\n        setRectangleDimensions(svgRect, 0, 0, legendLength, legendWidth);\r\n        svgRect.setAttribute(\"style\", `fill:url(#${legendGradientName})`);\r\n    } else if (gradient.type === \"steps\") {\r\n        for (let i: number = 1; i < gradient.stops.length; ++i) {\r\n            let rect: SVGRectElement = svgMake.rect();\r\n            container.appendChild(rect);\r\n\r\n            setRectangleDimensions(rect,\r\n                gradient.stops[i-1].position,\r\n                0,\r\n                gradient.stops[i].position - gradient.stops[i-1].position,\r\n                legendWidth\r\n            );\r\n            rect.setAttribute(\"style\", `fill:${gradient.stops[i-1][colorType]}`);\r\n        }\r\n        let rect: SVGRectElement = svgMake.rect();\r\n        container.appendChild(rect);\r\n        setRectangleDimensions(rect,\r\n            gradient.stops[gradient.stops.length-1].position,\r\n            0,\r\n            100 - gradient.stops[gradient.stops.length-1].position,\r\n            legendWidth\r\n        );\r\n        rect.setAttribute(\"style\", `fill:${gradient.stops[gradient.stops.length-1][colorType]}`);\r\n    }\r\n}\r\n\r\nfunction placeLabels(svgMake: SVGElementCreator, settings: LegendSettings, gradient: Gradient, container: Element): void {\r\n    if (settings.type === \"\" || settings.type[1] === \"n\") {\r\n        // no labels\r\n        return;\r\n    }\r\n\r\n    for (let stop of gradient.stops) {\r\n        if (!stop.showLegendLabel) {\r\n            continue;\r\n        }\r\n\r\n        let xCoord: number = settings.x;\r\n        let yCoord: number = settings.y;\r\n        let dy: number = 0.0;\r\n        let textAnchor: \"start\"|\"middle\"|\"end\" = \"start\";\r\n\r\n        if (settings.type[0] === \"h\") {\r\n            // horizontal scale\r\n            xCoord += stop.position * settings.length / legendLength;\r\n\r\n            textAnchor = \"middle\";\r\n            if (settings.type === \"hb\") {\r\n                yCoord += 2 * settings.width;\r\n                dy = 1.0;\r\n            }\r\n        } else if (settings.type[0] === \"v\") {\r\n            // vertical scale\r\n            yCoord += settings.length - (stop.position * settings.length / legendLength);\r\n            dy = 0.4;\r\n\r\n            if (settings.type === \"vl\") {\r\n                textAnchor = \"end\";\r\n            } else if (settings.type === \"vr\") {\r\n                textAnchor = \"start\";\r\n                xCoord += 2 * settings.width;\r\n            }\r\n        }\r\n\r\n        let label: SVGTextElement = svgMake.text();\r\n        container.appendChild(label);\r\n        label.setAttribute(\"class\", \"legend-label\");\r\n        label.setAttribute(\"x\", `${xCoord}`);\r\n        label.setAttribute(\"y\", `${yCoord}`);\r\n        label.setAttribute(\"dy\", `${dy}em`);\r\n        label.setAttribute(\"style\", `text-anchor:${textAnchor}`);\r\n        label.textContent = `${stop.position}`;\r\n    }\r\n}\r\n\r\nexport interface LegendSettings {\r\n    type: \"\"|\"hn\"|\"ha\"|\"hb\"|\"vn\"|\"vl\"|\"vr\";\r\n    x: number;\r\n    y: number;\r\n    length: number;\r\n    width: number;\r\n}\r\n","import { svgNamespace, xlinkNamespace } from \"./constants\";\r\nimport { deg2rad, halveCubicBezier, normalizeAngle, Point2D, polarToCartesian, unitVector } from \"./geometry\";\r\nimport { Gradient, GradientStop, gradientColorForValue } from \"./gradients\";\r\nimport { LegendSettings, placeLegend } from \"./legend\";\r\n\r\nexport function renderWeathermapInto(\r\n    elementCreator: SVGElementCreatorDOM, container: Node, config: WeathermapConfig, currentValues: MetricValueMap,\r\n    linkResolver: ((linkSettings: ObjectLinkSettings) => string|null)|null|undefined, addViewBox: boolean = false\r\n): SVGSVGElement {\r\n    // sort gradient stops\r\n    let sortedStops: GradientStop[] = config.gradient.stops\r\n        .slice()\r\n        .sort((l, r) => l.position - r.position);\r\n    let sortedGradient: Gradient = {\r\n        type: config.gradient.type,\r\n        stops: sortedStops\r\n    };\r\n\r\n    let state = new WeathermapRendererState(elementCreator, config, sortedGradient, currentValues);\r\n\r\n    initializeSVG(state, container, addViewBox);\r\n\r\n    // resolve links\r\n    if (linkResolver != null) {\r\n        state.nodeLinkUriBase = linkResolver(config.link.node);\r\n        state.edgeLinkUriBase = linkResolver(config.link.edge);\r\n    }\r\n\r\n    // emplacement\r\n    placeNodes(state);\r\n    placeEdges(state);\r\n    placeLabels(state);\r\n    placeLegend(state.make, config.legend, state.legendGroup!, state.defs!, sortedGradient, `${config.id}`);\r\n\r\n    return state.svg!;\r\n}\r\n\r\nfunction initializeSVG(state: WeathermapRendererState, container: Node, addViewBox: boolean = false): void {\r\n    // add SVG\r\n    state.svg = state.make.svg();\r\n    modifyStyle(state.svg, {\r\n        \"width\": `${state.config.canvasSize.width}px`,\r\n        \"height\": `${state.config.canvasSize.height}px`,\r\n    });\r\n    if (addViewBox) {\r\n        state.svg.setAttribute(\"viewBox\", `0 0 ${state.config.canvasSize.width} ${state.config.canvasSize.height}`);\r\n    }\r\n    container.appendChild(state.svg);\r\n\r\n    state.defs = state.make.defs();\r\n    state.svg.appendChild(state.defs);\r\n\r\n    state.legendGroup = state.make.g();\r\n    state.legendGroup.setAttribute(\"class\", \"legend\");\r\n    state.svg.appendChild(state.legendGroup);\r\n\r\n    state.edgeGroup = state.make.g();\r\n    state.edgeGroup.setAttribute(\"class\", \"edges\");\r\n    state.svg.appendChild(state.edgeGroup);\r\n\r\n    state.nodeGroup = state.make.g();\r\n    state.nodeGroup.setAttribute(\"class\", \"nodes\");\r\n    state.svg.appendChild(state.nodeGroup);\r\n\r\n    state.labelGroup = state.make.g();\r\n    state.labelGroup.setAttribute(\"class\", \"labels\");\r\n    state.svg.appendChild(state.labelGroup);\r\n}\r\n\r\nfunction placeNodes(state: WeathermapRendererState): void {\r\n    for (let node of state.config.weathermapNodes) {\r\n        state.nodeLabelToNode[node.label] = node;\r\n\r\n        let singleNodeGroup: SVGGElement = state.make.g();\r\n        maybeWrapIntoLink(state.make, state.nodeGroup!, singleNodeGroup, state.nodeLinkUriBase, node.linkParams);\r\n\r\n        let rect: SVGRectElement = state.make.rect();\r\n        singleNodeGroup.appendChild(rect);\r\n\r\n        setRectangleDimensions(rect, node.x, node.y, node.width, node.height);\r\n        modifyStyle(rect, {\r\n            \"stroke\": \"gray\",\r\n            \"stroke-width\": \"1px\",\r\n        });\r\n\r\n        let text: SVGTextElement = state.make.text();\r\n        singleNodeGroup.appendChild(text);\r\n\r\n        text.setAttribute(\"x\", `${(+node.x) + (+state.config.textOffsets.left)}`);\r\n        text.setAttribute(\"y\", `${(+node.y) + (+node.height) - state.config.textOffsets.bottom}`);\r\n        if (state.config.showNumbers && node.metricName != null) {\r\n            let value: string = (node.metricName in state.currentValues)\r\n                ? `${state.currentValues[node.metricName]}`\r\n                : \"?\"\r\n            ;\r\n            text.textContent = `${node.label} (${value})`;\r\n        } else {\r\n            text.textContent = node.label;\r\n        }\r\n\r\n        let currentValue: number|null = null;\r\n        if (!node.metricName) {\r\n            modifyStyle(rect, {\r\n                \"fill\": \"silver\",\r\n                \"stroke-dasharray\": state.config.unmeasuredDashArray,\r\n            });\r\n        } else if (node.metricName in state.currentValues) {\r\n            // color node by metric\r\n            currentValue = state.currentValues[node.metricName];\r\n            modifyStyle(rect, {\r\n                \"fill\": gradientColorForValue(state.sortedGradient, \"fillColor\", currentValue),\r\n            });\r\n        } else {\r\n            // no data\r\n            modifyStyle(text, {\r\n                \"fill\": \"white\",\r\n            });\r\n            modifyStyle(rect, {\r\n                \"fill\": \"black\",\r\n                \"stroke-dasharray\": state.config.noValueDashArray,\r\n            });\r\n        }\r\n\r\n        if (currentValue !== null) {\r\n            let titleElem: SVGTitleElement = state.make.title();\r\n            singleNodeGroup.insertBefore(titleElem, titleElem.firstChild);\r\n            titleElem.textContent = `${node.label} (${currentValue.toFixed(2)})`;\r\n        }\r\n    }\r\n}\r\n\r\nfunction placeEdges(state: WeathermapRendererState): void {\r\n    // place edges\r\n    for (let edge of state.config.weathermapEdges) {\r\n        let node1: WeathermapNode = state.nodeLabelToNode[edge.node1];\r\n        let node2: WeathermapNode = state.nodeLabelToNode[edge.node2];\r\n        if (!node1 || !node2) {\r\n            // TODO: output error\r\n            continue;\r\n        }\r\n\r\n        let singleEdgeGroup: SVGGElement = state.make.g();\r\n        maybeWrapIntoLink(state.make, state.edgeGroup!, singleEdgeGroup, state.edgeLinkUriBase, edge.linkParams);\r\n\r\n        let n1Center: Point2D = {\r\n            x: (+node1.x) + ((+node1.width) / 2),\r\n            y: (+node1.y) + ((+node1.height) / 2)\r\n        };\r\n        let n2Center: Point2D = {\r\n            x: (+node2.x) + ((+node2.width) / 2),\r\n            y: (+node2.y) + ((+node2.height) / 2)\r\n        };\r\n\r\n        // calculate bend (control points)\r\n        let control1: Point2D|null = null;\r\n        let control2: Point2D|null = null;\r\n        if (edge.bendDirection && edge.bendMagnitude) {\r\n            // warning: screen coordinates (flipped Y axis)!\r\n            let n1N2Angle: number = Math.atan2(n1Center.y - n2Center.y, n2Center.x - n1Center.x);\r\n            let n2N1Angle: number = Math.atan2(n2Center.y - n1Center.y, n1Center.x - n2Center.x);\r\n\r\n            let n1N2BendAngle: number = normalizeAngle(n1N2Angle + deg2rad(edge.bendDirection));\r\n            let n2N1BendAngle: number = normalizeAngle(n2N1Angle - deg2rad(edge.bendDirection));\r\n\r\n            let control1Offset: Point2D = polarToCartesian(n1N2BendAngle, edge.bendMagnitude);\r\n            let control2Offset: Point2D = polarToCartesian(n2N1BendAngle, edge.bendMagnitude);\r\n\r\n            control1 = {\r\n                x: (+n1Center.x) + control1Offset.x,\r\n                y: (+n1Center.y) - control1Offset.y\r\n            };\r\n            control2 = {\r\n                x: (+n2Center.x) + control2Offset.x,\r\n                y: (+n2Center.y) - control2Offset.y\r\n            };\r\n        }\r\n\r\n        if (edge.metric2Name) {\r\n            // two metrics are twice the fun\r\n            let\r\n                [, point1COut, point2CIn, point2, point2COut, point3CIn,]\r\n            =\r\n                halveCubicBezier(n1Center, control1, control2, n2Center)\r\n            ;\r\n\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                n1Center, point1COut, point2CIn, point2,\r\n                edge.metricName, edge.styleName,\r\n                `${edge.node1} \\u2192 ${edge.node2}`\r\n            );\r\n\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                point2, point2COut, point3CIn, n2Center,\r\n                edge.metric2Name, edge.styleName,\r\n                `${edge.node2} \\u2192 ${edge.node1}`\r\n            );\r\n        } else {\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                n1Center, control1, control2, n2Center,\r\n                edge.metricName, edge.styleName,\r\n                `${edge.node1} \\u2194 ${edge.node2}`\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nfunction placeLabels(state: WeathermapRendererState): void {\r\n    for (let label of state.config.weathermapLabels) {\r\n        let singleLabelGroup: SVGGElement = state.make.g();\r\n        state.labelGroup!.appendChild(singleLabelGroup);\r\n\r\n        let text: SVGTextElement = state.make.text();\r\n        singleLabelGroup.appendChild(text);\r\n\r\n        text.setAttribute(\"x\", `${+label.x}`);\r\n        text.setAttribute(\"y\", `${+label.y}`);\r\n        text.textContent = label.label;\r\n    }\r\n}\r\n\r\nfunction makeAndPlaceEdge(\r\n    state: WeathermapRendererState, singleEdgeGroup: SVGGElement, start: Point2D, control1: Point2D|null,\r\n    control2: Point2D|null, end: Point2D, metricName: string|null|undefined, edgeStyleName: string|null|undefined,\r\n    title: string|null|undefined\r\n): void {\r\n    let strokeWidths: number[] = [state.config.strokeWidth];\r\n    let edgeStyle: WeathermapStyle|null = getWeathermapStyle(state, edgeStyleName);\r\n    if (edgeStyle && edgeStyle.strokeWidthArray) {\r\n        let pieces: string[] = edgeStyle.strokeWidthArray.split(/[ ,]+/);\r\n        strokeWidths = pieces.map(p => Number.parseFloat(p));\r\n    }\r\n\r\n    if (strokeWidths.length % 2 !== 1) {\r\n        // like stroke-dasharray, double the elements\r\n        strokeWidths.push(...strokeWidths);\r\n    }\r\n\r\n    let offsetUnitVector: Point2D = {x: 0, y: 0};\r\n    if (strokeWidths.length > 1) {\r\n        // calculate an actual offset vector\r\n\r\n        // get the direction\r\n        let direction: Point2D = {\r\n            x: start.x - end.x,\r\n            y: start.y - end.y\r\n        };\r\n\r\n        // rotate 90°; that's the offset vector\r\n        let offsetVector: Point2D = {\r\n            x: direction.y,\r\n            y: -direction.x\r\n        };\r\n\r\n        // calculate unit vector\r\n        offsetUnitVector = unitVector(offsetVector);\r\n    }\r\n\r\n    let multistrokeGroup: SVGGElement = state.make.g();\r\n    singleEdgeGroup.appendChild(multistrokeGroup);\r\n    modifyStyle(multistrokeGroup, {\r\n        \"fill\": \"none\",\r\n    });\r\n\r\n    let currentValue: number|null = null;\r\n    if (metricName != null && metricName in state.currentValues) {\r\n        currentValue = state.currentValues[metricName];\r\n        modifyStyle(multistrokeGroup, {\r\n            \"stroke\": gradientColorForValue(state.sortedGradient, \"strokeColor\", currentValue)\r\n        });\r\n        modifyApplyingWeathermapStyle(state, multistrokeGroup, edgeStyle);\r\n    } else {\r\n        modifyStyle(multistrokeGroup, {\r\n            \"stroke\": \"black\",\r\n            \"stroke-dasharray\": state.config.noValueDashArray\r\n        });\r\n    }\r\n\r\n    if (title) {\r\n        let titleElem: SVGTitleElement = state.make.title();\r\n        multistrokeGroup.appendChild(titleElem);\r\n        titleElem.textContent = (currentValue === null)\r\n            ? title\r\n            : `${title} (${currentValue.toFixed(2)})`\r\n        ;\r\n    }\r\n\r\n    let totalStrokeWidth: number = strokeWidths.reduce((acc, cur) => acc + cur, 0);\r\n    let currentOffset: number = -totalStrokeWidth/2.0;\r\n    let isSpacing: boolean = true;\r\n    for (let strokeWidth of strokeWidths) {\r\n        isSpacing = !isSpacing;\r\n        if (isSpacing) {\r\n            currentOffset += strokeWidth;\r\n            continue;\r\n        }\r\n\r\n        // calculate offset\r\n        let xOffset: number = offsetUnitVector.x * (currentOffset + strokeWidth/2.0);\r\n        let yOffset: number = offsetUnitVector.y * (currentOffset + strokeWidth/2.0);\r\n\r\n        let strokeStart: Point2D = {\r\n            x: start.x + xOffset,\r\n            y: start.y + yOffset,\r\n        };\r\n        let strokeControl1: Point2D|null = (control1 == null) ? null : {\r\n            x: control1.x + xOffset,\r\n            y: control1.y + yOffset,\r\n        };\r\n        let strokeControl2: Point2D|null = (control2 == null) ? null : {\r\n            x: control2.x + xOffset,\r\n            y: control2.y + yOffset,\r\n        };\r\n        let strokeEnd: Point2D = {\r\n            x: end.x + xOffset,\r\n            y: end.y + yOffset,\r\n        };\r\n\r\n        // make the path\r\n        let path: SVGPathElement = state.make.path();\r\n        multistrokeGroup.appendChild(path);\r\n        if (strokeControl1 == null || strokeControl2 == null) {\r\n            path.setAttribute(\"d\",\r\n                `M ${strokeStart.x},${strokeStart.y} ` +\r\n                `L ${strokeEnd.x},${strokeEnd.y}`\r\n            );\r\n        } else {\r\n            path.setAttribute(\"d\",\r\n                `M ${strokeStart.x},${strokeStart.y} ` +\r\n                `C ${strokeControl1.x},${strokeControl1.y},${strokeControl2.x},${strokeControl2.y},${strokeEnd.x},${strokeEnd.y}`\r\n            );\r\n        }\r\n\r\n        // apply the specific stroke width\r\n        modifyStyle(path, {\r\n            \"stroke-width\": `${strokeWidth}`,\r\n        });\r\n\r\n        currentOffset += strokeWidth;\r\n    }\r\n\r\n    if (state.config.showNumbers) {\r\n        let midpoint: Point2D = halveCubicBezier(start, control1, control2, end)[3];\r\n        let valueString: string = (metricName != null && metricName in state.currentValues)\r\n            ? state.currentValues[metricName].toFixed(2)\r\n            : \"?\"\r\n        ;\r\n        let text: SVGTextElement = state.make.text();\r\n        singleEdgeGroup.appendChild(text);\r\n        text.setAttribute(\"x\", `${midpoint.x}`);\r\n        text.setAttribute(\"y\", `${midpoint.y}`);\r\n        text.textContent = valueString;\r\n    }\r\n}\r\n\r\nfunction maybeWrapIntoLink(\r\n    svgMake: SVGElementCreator, upperGroup: SVGGElement, singleObjectGroup: SVGGElement,\r\n    linkUriBase: string|null|undefined, objLinkParams: string|null|undefined\r\n): void {\r\n    if (linkUriBase != null) {\r\n        let objLinkUri: string = linkUriBase;\r\n        if (objLinkParams != null) {\r\n            objLinkUri += (objLinkUri.indexOf(\"?\") === -1)\r\n                ? \"?\"\r\n                : \"&\";\r\n\r\n            objLinkUri += objLinkParams;\r\n        }\r\n\r\n        let aElement: SVGAElement = svgMake.a();\r\n        upperGroup.appendChild(aElement);\r\n        aElement.setAttributeNS(xlinkNamespace, \"href\", objLinkUri);\r\n\r\n        aElement.appendChild(singleObjectGroup);\r\n    } else {\r\n        upperGroup.appendChild(singleObjectGroup);\r\n    }\r\n}\r\n\r\nexport function setRectangleDimensions(\r\n    element: SVGRectElement, x: number|string, y: number|string, width: number|string, height: number|string\r\n): void {\r\n    element.setAttribute(\"x\", `${x}`);\r\n    element.setAttribute(\"y\", `${y}`);\r\n    element.setAttribute(\"width\", `${width}`);\r\n    element.setAttribute(\"height\", `${height}`);\r\n}\r\n\r\nfunction modifyStyle(element: Element, newValues: object): void {\r\n    // parse style\r\n    let assembledStyle: StringMapping<string> = {};\r\n    if (element.hasAttribute(\"style\")) {\r\n        let styleVal: string|null = element.getAttribute(\"style\");\r\n        if (styleVal != null) {\r\n            for (let chunk of styleVal.split(\";\")) {\r\n                let index: number = chunk.indexOf(\":\");\r\n                if (index === -1) {\r\n                    continue;\r\n                }\r\n                let key: string = chunk.substr(0, index);\r\n                let value: string = chunk.substr(index + 1);\r\n                assembledStyle[key] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let key in newValues) {\r\n        if (newValues.hasOwnProperty(key)) {\r\n            if (newValues[key] === null) {\r\n                delete assembledStyle[key];\r\n            } else {\r\n                assembledStyle[key] = newValues[key];\r\n            }\r\n        }\r\n    }\r\n\r\n    let keyValuePairs: string[] = [];\r\n    for (let key in assembledStyle) {\r\n        if (assembledStyle.hasOwnProperty(key)) {\r\n            keyValuePairs.push(`${key}:${assembledStyle[key]}`);\r\n        }\r\n    }\r\n\r\n    let keyValueString: string = keyValuePairs.join(\";\");\r\n    element.setAttribute(\"style\", keyValueString);\r\n}\r\n\r\nfunction getWeathermapStyle(\r\n    state: WeathermapRendererState, styleName: string|null|undefined\r\n): WeathermapStyle|null {\r\n    if (!styleName) {\r\n        return null;\r\n    }\r\n\r\n    let style: WeathermapStyle|undefined = state.styleMap[styleName];\r\n    if (!style) {\r\n        return null;\r\n    }\r\n    return style;\r\n}\r\n\r\nfunction modifyApplyingWeathermapStyle(\r\n    state: WeathermapRendererState, element: Element, style: WeathermapStyle|null\r\n): void {\r\n    if (!style) {\r\n        return;\r\n    }\r\n\r\n    let styleProps: StringMapping<string> = {};\r\n    if (style.dashArray) {\r\n        styleProps[\"stroke-dasharray\"] = style.dashArray;\r\n    }\r\n    // style.strokeWidthArray is handled beforehand\r\n\r\n    modifyStyle(element, styleProps);\r\n}\r\n\r\n\r\nexport class WeathermapRendererState {\r\n    make: SVGElementCreator;\r\n    config: WeathermapConfig;\r\n    sortedGradient: Gradient;\r\n    currentValues: MetricValueMap;\r\n    nodeLabelToNode: LabelToNodeMap;\r\n    nodeLinkUriBase: string|null;\r\n    edgeLinkUriBase: string|null;\r\n    svg: SVGSVGElement|null;\r\n    defs: SVGDefsElement|null;\r\n    edgeGroup: SVGGElement|null;\r\n    nodeGroup: SVGGElement|null;\r\n    labelGroup: SVGGElement|null;\r\n    legendGroup: SVGGElement|null;\r\n    styleMap: NameToStyleMap;\r\n\r\n    constructor(\r\n        domCreator: SVGElementCreatorDOM, config: WeathermapConfig, sortedGradient: Gradient, currentValues: MetricValueMap\r\n    ) {\r\n        this.make = new SVGElementCreator(domCreator);\r\n        this.config = config;\r\n        this.sortedGradient = sortedGradient;\r\n        this.currentValues = currentValues;\r\n        this.nodeLabelToNode = {};\r\n        this.nodeLinkUriBase = null;\r\n        this.edgeLinkUriBase = null;\r\n        this.svg = null;\r\n        this.defs = null;\r\n        this.edgeGroup = null;\r\n        this.nodeGroup = null;\r\n        this.labelGroup = null;\r\n        this.legendGroup = null;\r\n\r\n        this.styleMap = {};\r\n        if (config.weathermapStyles) {\r\n            for (let style of config.weathermapStyles) {\r\n                this.styleMap[style.name] = style;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class SVGElementCreator {\r\n    maker: SVGElementCreatorDOM;\r\n\r\n    constructor(maker: SVGElementCreatorDOM) { this.maker = maker; }\r\n\r\n    a() { return <SVGAElement>this.maker.createElementNS(svgNamespace, \"a\"); }\r\n    defs() { return <SVGDefsElement>this.maker.createElementNS(svgNamespace, \"defs\"); }\r\n    g() { return <SVGGElement>this.maker.createElementNS(svgNamespace, \"g\"); }\r\n    linearGradient() { return <SVGLinearGradientElement>this.maker.createElementNS(svgNamespace, \"linearGradient\"); }\r\n    path() { return <SVGPathElement>this.maker.createElementNS(svgNamespace, \"path\"); }\r\n    rect() { return <SVGRectElement>this.maker.createElementNS(svgNamespace, \"rect\"); }\r\n    stop() { return <SVGStopElement>this.maker.createElementNS(svgNamespace, \"stop\"); }\r\n    svg() { return <SVGSVGElement>this.maker.createElementNS(svgNamespace, \"svg\"); }\r\n    text() { return <SVGTextElement>this.maker.createElementNS(svgNamespace, \"text\"); }\r\n    title() { return <SVGTitleElement>this.maker.createElementNS(svgNamespace, \"title\"); }\r\n}\r\n\r\nexport interface SVGElementCreatorDOM {\r\n    createElementNS(namespaceURI: string, qualifiedName: string): Element;\r\n}\r\n\r\ninterface PositionableTextElement {\r\n    label: string;\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport interface WeathermapNode extends PositionableTextElement {\r\n    width: number;\r\n    height: number;\r\n    metricName?: string|null;\r\n    linkParams?: string;\r\n}\r\n\r\nexport interface WeathermapEdge {\r\n    node1: string;\r\n    node2: string;\r\n    bendDirection?: number;\r\n    bendMagnitude?: number;\r\n    metricName?: string;\r\n    metric2Name?: string|null;\r\n    linkParams?: string;\r\n    styleName?: string;\r\n}\r\n\r\nexport interface WeathermapLabel extends PositionableTextElement {\r\n}\r\n\r\nexport interface WeathermapStyle {\r\n    name: string;\r\n    strokeWidthArray?: string;\r\n    dashArray?: string;\r\n}\r\n\r\ninterface LinkSettings {\r\n    node: ObjectLinkSettings;\r\n    edge: ObjectLinkSettings;\r\n}\r\n\r\nexport interface StringMapping<V> {\r\n    [key: string]: V;\r\n}\r\n\r\nexport type LabelToNodeMap = StringMapping<WeathermapNode>;\r\nexport type MetricValueMap = StringMapping<number>;\r\nexport type NameToStyleMap = StringMapping<WeathermapStyle>;\r\n\r\nexport interface ObjectLinkSettings {\r\n    type: \"none\"|\"dashboard\"|\"absolute\";\r\n    dashboard: string|null;\r\n    dashUri: string|null;\r\n    absoluteUri: string|null;\r\n}\r\n\r\nexport interface WeathermapDefaultConfig {\r\n    weathermapEdges: WeathermapEdge[];\r\n    weathermapNodes: WeathermapNode[];\r\n    weathermapLabels: WeathermapLabel[];\r\n    weathermapStyles: WeathermapStyle[];\r\n    canvasSize: { width: number; height: number; };\r\n    textOffsets: { left: number; bottom: number; };\r\n    showNumbers: boolean;\r\n    valueName: \"max\"|\"min\"|\"avg\"|\"current\"|\"total\";\r\n    nullPointMode: \"connected\"|\"null\"|\"null as zero\";\r\n    strokeWidth: number;\r\n    gradient: Gradient;\r\n    legend: LegendSettings;\r\n    link: LinkSettings;\r\n    noValueDashArray: string;\r\n    unmeasuredDashArray: string;\r\n}\r\n\r\nexport interface WeathermapConfig extends WeathermapDefaultConfig {\r\n    id: number;\r\n}\r\n","import { MetricsPanelCtrl } from 'grafana/app/plugins/sdk';\r\nimport { editorPath, nodeEditorPath, edgeEditorPath, labelEditorPath, styleEditorPath } from \"./properties\";\r\nimport {\r\n    renderWeathermapInto,\r\n    WeathermapConfig,\r\n    WeathermapDefaultConfig,\r\n    WeathermapNode,\r\n    WeathermapEdge,\r\n    WeathermapLabel,\r\n    WeathermapStyle,\r\n    ObjectLinkSettings,\r\n    StringMapping\r\n} from \"./svg-weathermap/weathermap\";\r\nimport {\r\n    GradientStop\r\n} from \"./svg-weathermap/gradients\";\r\nimport _ from \"lodash\";\r\nimport TimeSeries from \"grafana/app/core/time_series2\";\r\n\r\nconst panelDefaults: WeathermapDefaultConfig = {\r\n    // data\r\n    weathermapNodes: [],\r\n    weathermapEdges: [],\r\n    weathermapLabels: [],\r\n    weathermapStyles: [],\r\n    canvasSize: {\r\n        width: 800,\r\n        height: 600\r\n    },\r\n    textOffsets: {\r\n        left: 5,\r\n        bottom: 5\r\n    },\r\n    showNumbers: false,\r\n    valueName: \"max\",\r\n    nullPointMode: \"connected\",\r\n    strokeWidth: 1,\r\n    gradient: {\r\n        type: \"steps\",\r\n        stops: []\r\n    },\r\n    legend: {\r\n        type: \"\",\r\n        x: 0,\r\n        y: 0,\r\n        length: 100,\r\n        width: 5\r\n    },\r\n    link: {\r\n        node: {\r\n            type: \"none\",\r\n            absoluteUri: null,\r\n            dashboard: null,\r\n            dashUri: null\r\n        },\r\n        edge: {\r\n            type: \"none\",\r\n            absoluteUri: null,\r\n            dashboard: null,\r\n            dashUri: null\r\n        }\r\n    },\r\n    noValueDashArray: \"4 4\",\r\n    unmeasuredDashArray: \"4 2\",\r\n};\r\n\r\nexport class WeathermapCtrl extends MetricsPanelCtrl {\r\n    static templateUrl: string;\r\n    currentValues: {[key: string]: number;};\r\n    currentSeries: object;\r\n\r\n    panel: WeathermapConfig;\r\n\r\n    searchDashboards: (queryStr: string, callback: (matches: string[]) => any) => void;\r\n\r\n    /** @ngInject **/\r\n    constructor($scope: any, $injector: any, private backendSrv: any) {\r\n        super($scope, $injector);\r\n        _.defaultsDeep(this.panel, panelDefaults);\r\n\r\n        this.currentValues = {};\r\n\r\n        this.events.on(\"init-edit-mode\", this.onInitEditMode.bind(this));\r\n        this.events.on(\"data-received\", this.onDataReceived.bind(this));\r\n        this.events.on(\"data-snapshot-load\", this.onDataSnapshotLoad.bind(this));\r\n\r\n        this.searchDashboards = function (queryStr: string, callback: (matches: string[]) => any): void {\r\n            backendSrv.search({query: queryStr}).then(hits => {\r\n                let dashboards: any[] = _.map(hits, dash => dash.title);\r\n                callback(dashboards);\r\n            });\r\n        };\r\n    }\r\n\r\n    onInitEditMode(): void {\r\n        this.addEditorTab(\"Options\", editorPath, 2);\r\n        this.addEditorTab(\"Nodes\", nodeEditorPath, 3);\r\n        this.addEditorTab(\"Edges\", edgeEditorPath, 4);\r\n        this.addEditorTab(\"Labels\", labelEditorPath, 5);\r\n        this.addEditorTab(\"Styles\", styleEditorPath, 6);\r\n    }\r\n\r\n    onDataReceived(dataList: any): void {\r\n        this.currentSeries = dataList.map(this.seriesHandler.bind(this));\r\n        this.currentValues = this.parseSeries(this.currentSeries);\r\n\r\n        this.render();\r\n    }\r\n\r\n    seriesHandler(seriesData: any): TimeSeries {\r\n        let series = new TimeSeries({\r\n            datapoints: seriesData.datapoints,\r\n            alias: seriesData.target\r\n        });\r\n        series.getFlotPairs(this.panel.nullPointMode);\r\n        return series;\r\n    }\r\n\r\n    parseSeries(series: any): StringMapping<number> {\r\n        let targetToValue: StringMapping<number> = {};\r\n        for (let ser of series) {\r\n            targetToValue[ser.alias] = ser.stats[this.panel.valueName];\r\n        }\r\n        return targetToValue;\r\n    }\r\n\r\n    onDataSnapshotLoad(snapshotData: any): void {\r\n        this.onDataReceived(snapshotData);\r\n    }\r\n\r\n    addWeathermapNode(node?: WeathermapNode): void {\r\n        this.panel.weathermapNodes.push(node || <WeathermapNode>{});\r\n    }\r\n    removeWeathermapNode(node: WeathermapNode): void {\r\n        this.panel.weathermapNodes = _.without(this.panel.weathermapNodes, node);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapEdge(edge?: WeathermapEdge): void {\r\n        this.panel.weathermapEdges.push(edge || <WeathermapEdge>{});\r\n    }\r\n    removeWeathermapEdge(edge: WeathermapEdge): void {\r\n        this.panel.weathermapEdges = _.without(this.panel.weathermapEdges, edge);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapLabel(label?: WeathermapLabel): void {\r\n        this.panel.weathermapLabels.push(label || <WeathermapLabel>{});\r\n    }\r\n    removeWeathermapLabel(label: WeathermapLabel): void {\r\n        this.panel.weathermapLabels = _.without(this.panel.weathermapLabels, label);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapStyle(style?: WeathermapStyle): void {\r\n        this.panel.weathermapStyles.push(style || <WeathermapStyle>{});\r\n    }\r\n    removeWeathermapStyle(style: WeathermapStyle): void {\r\n        this.panel.weathermapStyles = _.without(this.panel.weathermapStyles, style);\r\n        this.refresh();\r\n    }\r\n\r\n    addGradientStop(stop?: GradientStop): void {\r\n        this.panel.gradient.stops.push(stop || <GradientStop>{});\r\n    }\r\n    onGradientStopStrokeColorChange(stopIndex: number): (color: string) => void {\r\n        return (color: string) => {\r\n            this.panel.gradient.stops[stopIndex].strokeColor = color;\r\n            this.refresh();\r\n        };\r\n    }\r\n    onGradientStopFillColorChange(stopIndex: number): (color: string) => void {\r\n        return (color: string) => {\r\n            this.panel.gradient.stops[stopIndex].fillColor = color;\r\n            this.refresh();\r\n        };\r\n    }\r\n    removeGradientStop(stop: GradientStop): void {\r\n        this.panel.gradient.stops = _.without(this.panel.gradient.stops, stop);\r\n        this.refresh();\r\n    }\r\n\r\n    dashboardChanged(link: ObjectLinkSettings): void {\r\n        this.backendSrv.search({query: link.dashboard}).then((hits) => {\r\n            let dashboard: any = _.find(hits, {title: link.dashboard});\r\n            if (dashboard) {\r\n                link.dashUri = dashboard.uri;\r\n            }\r\n        });\r\n    }\r\n\r\n    link(_scope: any, elems: HTMLElement[], _attrs: any, ctrl: any): void {\r\n        this.events.on(\"render\", () => this.renderThat(elems[0], ctrl));\r\n    }\r\n\r\n    renderThat(topElem: HTMLElement, _ctrl: any): void {\r\n        // find weathermap div\r\n        let elem: Element|null = topElem.querySelector(\"div.weathermap\");\r\n        if (elem === null) {\r\n            // oh well\r\n            return;\r\n        }\r\n\r\n        // filicide\r\n        while (elem.lastChild) {\r\n            elem.removeChild(elem.lastChild);\r\n        }\r\n\r\n        // do it\r\n        renderWeathermapInto(document, elem, this.panel, this.currentValues, WeathermapCtrl.resolveLink);\r\n    }\r\n\r\n    static resolveLink(objLink: ObjectLinkSettings): string|null {\r\n        if (objLink.type === \"absolute\" && objLink.absoluteUri) {\r\n            return objLink.absoluteUri;\r\n        } else if (objLink.type === \"dashboard\" && objLink.dashUri) {\r\n            let url = new URL(window.location.href);\r\n            let oldParams: StringMapping<string> = getSearchParams(url);\r\n            let params: string[] = [];\r\n\r\n            if (oldParams.from) {\r\n                params.push(`from=${encodeURIComponent(oldParams.from)}`);\r\n            }\r\n\r\n            if (oldParams.to) {\r\n                params.push(`to=${encodeURIComponent(oldParams.to)}`);\r\n            }\r\n\r\n            let paramSuffix: string = \"\";\r\n            if (params.length > 0) {\r\n                paramSuffix = \"?\" + params.join(\"&\");\r\n            }\r\n            return `/dashboard/${objLink.dashUri}${paramSuffix}`;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nWeathermapCtrl.templateUrl = \"partials/module.html\";\r\n\r\nfunction getSearchParams(url: URL): StringMapping<string> {\r\n    let search: string = url.search;\r\n    while (search.startsWith(\"?\")) {\r\n        search = search.substr(1);\r\n    }\r\n\r\n    let params: StringMapping<string> = {};\r\n    if (search.length > 0) {\r\n        let pairs: string[] = search.split(\"&\");\r\n        for (let pair of pairs) {\r\n            let keyValueMatch: RegExpMatchArray|null = pair.match(/^([^=]*)(?:=(.*))?$/);\r\n            if (keyValueMatch === null) {\r\n                continue;\r\n            }\r\n\r\n            let key: string = keyValueMatch[1];\r\n            let value: string = keyValueMatch[2];\r\n            if (key !== undefined && value !== undefined) {\r\n                params[decodeURIComponent(key)] = decodeURIComponent(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return params;\r\n}\r\n","export const\r\n    pluginName: string = \"ravualhemio-weathermap-panel\",\r\n    editorPath: string = `public/plugins/${pluginName}/partials/editor.html`,\r\n    nodeEditorPath: string = `public/plugins/${pluginName}/partials/nodeEditor.html`,\r\n    edgeEditorPath: string = `public/plugins/${pluginName}/partials/edgeEditor.html`,\r\n    labelEditorPath: string = `public/plugins/${pluginName}/partials/labelEditor.html`,\r\n    styleEditorPath: string = `public/plugins/${pluginName}/partials/styleEditor.html`;\r\n"],"sourceRoot":""}