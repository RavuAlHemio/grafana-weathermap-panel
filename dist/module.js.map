{"version":3,"sources":["webpack:///external \"app/core/time_series2\"","webpack:///external \"app/plugins/sdk\"","webpack:///external \"lodash\"","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./svg-weathermap/constants.ts","webpack:///./svg-weathermap/geometry.ts","webpack:///./svg-weathermap/gradients.ts","webpack:///./svg-weathermap/legend.ts","webpack:///./svg-weathermap/weathermap.ts","webpack:///./weathermapControl.ts","webpack:///./properties.ts"],"names":["module","exports","__WEBPACK_EXTERNAL_MODULE__840__","__WEBPACK_EXTERNAL_MODULE__256__","__WEBPACK_EXTERNAL_MODULE__804__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","svgNamespace","midpoint","point1","point2","x","y","halveCubicBezier","control1","control2","straightMidpoint","m1","m2","m3","q1","q2","polarToCartesian","angleRadians","length","Math","cos","sin","normalizeAngle","PI","deg2rad","angleDegrees","emergencyColor","gradientColorForValue","gradient","colorType","type","stops","lastStop","g","b","position","foundMatch","i","posFrom","rFrom","Number","parseInt","substr","gFrom","bFrom","posTo","rTo","gTo","bTo","lerp","floor","linearColorForValue","stepColorForValue","sourceMin","sourceMax","targetMin","targetMax","legendLength","placeLegend","svgMake","settings","container","defs","weathermapID","transform","strokeLegendContainer","appendChild","setAttribute","width","drawLegend","fillLegendContainer","showLegendLabel","xCoord","yCoord","dy","textAnchor","label","text","textContent","placeLabels","legendGradientName","svgGrad","linearGradient","svgStop","stop","svgRect","rect","setRectangleDimensions","renderWeathermapInto","elementCreator","config","currentValues","linkResolver","addViewBox","sortedStops","slice","sort","l","sortedGradient","state","WeathermapRendererState","svg","make","modifyStyle","canvasSize","height","legendGroup","edgeGroup","nodeGroup","labelGroup","initializeSVG","nodeLinkUriBase","link","node","edgeLinkUriBase","edge","weathermapNodes","nodeLabelToNode","singleNodeGroup","maybeWrapIntoLink","linkParams","textOffsets","left","bottom","showNumbers","metricName","currentValue","noValueDashArray","unmeasuredDashArray","titleElem","title","insertBefore","firstChild","toFixed","placeNodes","weathermapEdges","node1","node2","singleEdgeGroup","n1Center","n2Center","bendDirection","bendMagnitude","n1N2Angle","atan2","n2N1Angle","n1N2BendAngle","n2N1BendAngle","control1Offset","control2Offset","metric2Name","point1COut","point2CIn","point2COut","point3CIn","makeAndPlaceEdge","styleName","placeEdges","weathermapLabels","singleLabelGroup","legend","id","start","end","edgeStyleName","strokeWidths","strokeWidth","edgeStyle","style","styleMap","getWeathermapStyle","strokeWidthArray","split","map","p","parseFloat","push","vector","euclidNorm","offsetUnitVector","direction","sqrt","multistrokeGroup","element","styleProps","dashArray","modifyApplyingWeathermapStyle","currentOffset","reduce","acc","cur","isSpacing","xOffset","yOffset","strokeStart","strokeControl1","strokeControl2","strokeEnd","path","valueString","upperGroup","singleObjectGroup","linkUriBase","objLinkParams","objLinkUri","indexOf","aElement","setAttributeNS","newValues","assembledStyle","hasAttribute","styleVal","getAttribute","chunk","index","keyValuePairs","keyValueString","join","domCreator","this","SVGElementCreator","weathermapStyles","name","maker","createElementNS","panelDefaults","valueName","nullPointMode","absoluteUri","dashboard","dashUri","$scope","$injector","backendSrv","panel","events","on","onInitEditMode","bind","onDataReceived","onDataSnapshotLoad","searchDashboards","queryStr","callback","search","query","then","hits","dashboards","dash","addEditorTab","dataList","currentSeries","seriesHandler","parseSeries","render","seriesData","series","datapoints","alias","target","getFlotPairs","targetToValue","ser","stats","snapshotData","addWeathermapNode","removeWeathermapNode","refresh","addWeathermapEdge","removeWeathermapEdge","addWeathermapLabel","removeWeathermapLabel","addWeathermapStyle","removeWeathermapStyle","addGradientStop","onGradientStopStrokeColorChange","stopIndex","color","strokeColor","onGradientStopFillColorChange","fillColor","removeGradientStop","dashboardChanged","url","_scope","elems","_attrs","ctrl","renderThat","topElem","_ctrl","elem","querySelector","lastChild","removeChild","document","WeathermapCtrl","resolveLink","objLink","oldParams","startsWith","params","keyValueMatch","match","decodeURIComponent","getSearchParams","URL","window","location","href","from","encodeURIComponent","to","paramSuffix","MetricsPanelCtrl","templateUrl"],"mappings":"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","file":"module.js","sourcesContent":["module.exports = __WEBPACK_EXTERNAL_MODULE__840__;","module.exports = __WEBPACK_EXTERNAL_MODULE__256__;","module.exports = __WEBPACK_EXTERNAL_MODULE__804__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const svgNamespace: string = \"http://www.w3.org/2000/svg\";\r\nexport const xlinkNamespace: string = \"http://www.w3.org/1999/xlink\";\r\n","export function midpoint(point1: Point2D, point2: Point2D): Point2D {\r\n    return {\r\n        x: (point1.x + point2.x)/2.0,\r\n        y: (point1.y + point2.y)/2.0\r\n    };\r\n}\r\n\r\nexport function halveCubicBezier(\r\n    point1: Point2D, control1: Point2D|null, control2: Point2D|null, point2: Point2D\r\n): [Point2D, Point2D, Point2D, Point2D, Point2D, Point2D, Point2D] {\r\n    if (control1 === null) {\r\n        if (control2 === null) {\r\n            // naïveté!\r\n            let straightMidpoint: Point2D = midpoint(point1, point2);\r\n            return [point1, point1, straightMidpoint, straightMidpoint, straightMidpoint, point2, point2];\r\n        }\r\n\r\n        control1 = point1;\r\n    }\r\n    if (control2 === null) {\r\n        control2 = point2;\r\n    }\r\n\r\n    let m1: Point2D = midpoint(point1, control1);\r\n    let m2: Point2D = midpoint(control1, control2);\r\n    let m3: Point2D = midpoint(control2, point2);\r\n\r\n    let q1: Point2D = midpoint(m1, m2);\r\n    let q2: Point2D = midpoint(m2, m3);\r\n\r\n    let o: Point2D = midpoint(q1, q2);\r\n\r\n    return [point1, m1, q1, o, q2, m3, point2];\r\n}\r\n\r\nexport function polarToCartesian(angleRadians: number|null, length: number|null): Point2D {\r\n    if (angleRadians === null) {\r\n        angleRadians = 0;\r\n    }\r\n    if (length === null) {\r\n        length = 0;\r\n    }\r\n\r\n    return {\r\n        x: length * Math.cos(angleRadians),\r\n        y: length * Math.sin(angleRadians)\r\n    };\r\n}\r\n\r\nexport function normalizeAngle(angleRadians: number): number {\r\n    while (angleRadians <= -Math.PI) {\r\n        angleRadians += 2 * Math.PI;\r\n    }\r\n    while (angleRadians > Math.PI) {\r\n        angleRadians -= 2 * Math.PI;\r\n    }\r\n    return angleRadians;\r\n}\r\n\r\nexport function unitVector(vector: Point2D): Point2D {\r\n    let euclidNorm: number = Math.sqrt(vector.x*vector.x + vector.y*vector.y);\r\n    return {\r\n        x: vector.x / euclidNorm,\r\n        y: vector.y / euclidNorm\r\n    };\r\n}\r\n\r\nexport function deg2rad(angleDegrees: number): number {\r\n    return angleDegrees * Math.PI / 180;\r\n}\r\n\r\nexport function rad2deg(angleRadians: number): number {\r\n    return angleRadians * 180 / Math.PI;\r\n}\r\n\r\nexport interface Point2D {\r\n    x: number;\r\n    y: number;\r\n}\r\n","const emergencyColor: string = \"pink\";\r\n\r\nexport function gradientColorForValue(gradient: Gradient, colorType: keyof GradientStop, value: number): string {\r\n    if (gradient.type === \"linear\") {\r\n        return linearColorForValue(gradient.stops, colorType, value);\r\n    } else if (gradient.type === \"steps\") {\r\n        return stepColorForValue(gradient.stops, colorType, value);\r\n    }\r\n    return emergencyColor;\r\n}\r\n\r\nfunction linearColorForValue(stops: GradientStop[], colorType: keyof GradientStop, value: number): string {\r\n    if (stops.length === 0) {\r\n        return emergencyColor;\r\n    }\r\n\r\n    let lastStop: GradientStop = stops[stops.length-1];\r\n    let r: number = 0.0, g: number = 0.0, b: number = 0.0;\r\n    if (value < stops[0].position) {\r\n        return `${stops[0][colorType]}`;\r\n    } else if (value >= lastStop.position) {\r\n        return `${lastStop[colorType]}`;\r\n    } else {\r\n        let foundMatch: boolean = false;\r\n        for (let i: number = 0; i < stops.length-1; ++i) {\r\n            if (value >= stops[i].position && value < stops[i+1].position) {\r\n                // found!\r\n\r\n                let posFrom: number = stops[i].position;\r\n                let rFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(1, 2), 16);\r\n                let gFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(3, 2), 16);\r\n                let bFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(5, 2), 16);\r\n\r\n                let posTo: number = stops[i+1].position;\r\n                let rTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(1, 2), 16);\r\n                let gTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(3, 2), 16);\r\n                let bTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(5, 2), 16);\r\n\r\n                r = lerp(value, posFrom, posTo, rFrom, rTo);\r\n                g = lerp(value, posFrom, posTo, gFrom, gTo);\r\n                b = lerp(value, posFrom, posTo, bFrom, bTo);\r\n\r\n                foundMatch = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!foundMatch) {\r\n            return emergencyColor;\r\n        }\r\n    }\r\n\r\n    return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;\r\n}\r\n\r\nfunction stepColorForValue(stops: GradientStop[], colorType: keyof GradientStop, value: number): string {\r\n    if (stops.length === 0) {\r\n        return emergencyColor;\r\n    }\r\n\r\n    let lastStop: GradientStop = stops[stops.length-1];\r\n    if (value < stops[0].position) {\r\n        return `${stops[0][colorType]}`;\r\n    } else if (value >= lastStop.position) {\r\n        return `${lastStop[colorType]}`;\r\n    } else {\r\n        for (let i: number = 0; i < stops.length-1; ++i) {\r\n            if (value >= stops[i].position && value < stops[i+1].position) {\r\n                return `${stops[i][colorType]}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    return emergencyColor;\r\n}\r\n\r\nfunction lerp(value: number, sourceMin: number, sourceMax: number, targetMin: number, targetMax: number): number {\r\n    if (targetMin === targetMax) {\r\n        return targetMin;\r\n    }\r\n\r\n    if (value < sourceMin) {\r\n        value = sourceMin;\r\n    }\r\n    if (value > sourceMax) {\r\n        value = sourceMax;\r\n    }\r\n\r\n    let terp: number = (value - sourceMin) / (sourceMax - sourceMin);\r\n    return targetMin + terp * (targetMax - targetMin);\r\n}\r\n\r\n\r\nexport interface GradientStop {\r\n    position: number;\r\n    strokeColor: string;\r\n    fillColor: string;\r\n    showLegendLabel: boolean;\r\n}\r\n\r\nexport interface Gradient {\r\n    type: \"steps\"|\"linear\";\r\n    stops: GradientStop[];\r\n}\r\n","import { Gradient, GradientStop } from \"./gradients\";\r\nimport { SVGElementCreator, setRectangleDimensions } from \"./weathermap\";\r\n\r\nconst legendLength: number = 100;\r\nconst legendWidth: number = 5;\r\n// (let the container apply any transformations)\r\n\r\nexport function placeLegend(\r\n    svgMake: SVGElementCreator, settings: LegendSettings, container: Element, defs: SVGDefsElement, gradient: Gradient,\r\n    weathermapID?: string|null\r\n): void {\r\n    let transform: string = \"\";\r\n\r\n    if (settings.type === \"\") {\r\n        // no legend\r\n        return;\r\n    }\r\n\r\n    // draw stroke-color legend\r\n    let strokeLegendContainer: SVGGElement = svgMake.g();\r\n    container.appendChild(strokeLegendContainer);\r\n    strokeLegendContainer.setAttribute(\"class\", \"stroke-legend\");\r\n    if (settings.type[0] === \"h\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y})`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    } else if (settings.type[0] === \"v\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y + settings.length})`\r\n            + ` rotate(-90)`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    }\r\n    strokeLegendContainer.setAttribute(\"transform\", transform);\r\n    drawLegend(svgMake, gradient, \"strokeColor\", strokeLegendContainer, defs, weathermapID);\r\n\r\n    // draw fill-color legend\r\n    let fillLegendContainer: SVGGElement = svgMake.g();\r\n    container.appendChild(fillLegendContainer);\r\n    strokeLegendContainer.setAttribute(\"class\", \"fill-legend\");\r\n    if (settings.type[0] === \"h\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y + settings.width})`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    } else if (settings.type[0] === \"v\") {\r\n        transform =\r\n            `translate(${settings.x + settings.width} ${settings.y + settings.length})`\r\n            + ` rotate(-90)`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    }\r\n    fillLegendContainer.setAttribute(\"transform\", transform);\r\n    drawLegend(svgMake, gradient, \"fillColor\", fillLegendContainer, defs, weathermapID);\r\n\r\n    // draw legend labels\r\n    placeLabels(svgMake, settings, gradient, container);\r\n}\r\n\r\nfunction drawLegend(\r\n    svgMake: SVGElementCreator, gradient: Gradient, colorType: keyof GradientStop, container: SVGElement,\r\n    defs: SVGDefsElement, weathermapID?: string|null\r\n): void {\r\n    if (gradient.type === \"linear\") {\r\n        let legendGradientName: string = `WeathermapLegendGradient-${colorType}`;\r\n        if (weathermapID != null) {\r\n            legendGradientName = `${legendGradientName}-${weathermapID}`;\r\n        }\r\n\r\n        let svgGrad: SVGLinearGradientElement = svgMake.linearGradient();\r\n        defs.appendChild(svgGrad);\r\n        svgGrad.setAttribute(\"id\", legendGradientName);\r\n\r\n        for (let stop of gradient.stops) {\r\n            let svgStop: SVGStopElement = svgMake.stop();\r\n            svgGrad.appendChild(svgStop);\r\n            svgStop.setAttribute(\"offset\", `${stop.position}%`);\r\n            svgStop.setAttribute(\"stop-color\", `${stop[colorType]}`);\r\n        }\r\n\r\n        let svgRect: SVGRectElement = svgMake.rect();\r\n        container.appendChild(svgRect);\r\n        setRectangleDimensions(svgRect, 0, 0, legendLength, legendWidth);\r\n        svgRect.setAttribute(\"style\", `fill:url(#${legendGradientName})`);\r\n    } else if (gradient.type === \"steps\") {\r\n        for (let i: number = 1; i < gradient.stops.length; ++i) {\r\n            let rect: SVGRectElement = svgMake.rect();\r\n            container.appendChild(rect);\r\n\r\n            setRectangleDimensions(rect,\r\n                gradient.stops[i-1].position,\r\n                0,\r\n                gradient.stops[i].position - gradient.stops[i-1].position,\r\n                legendWidth\r\n            );\r\n            rect.setAttribute(\"style\", `fill:${gradient.stops[i-1][colorType]}`);\r\n        }\r\n        let rect: SVGRectElement = svgMake.rect();\r\n        container.appendChild(rect);\r\n        setRectangleDimensions(rect,\r\n            gradient.stops[gradient.stops.length-1].position,\r\n            0,\r\n            100 - gradient.stops[gradient.stops.length-1].position,\r\n            legendWidth\r\n        );\r\n        rect.setAttribute(\"style\", `fill:${gradient.stops[gradient.stops.length-1][colorType]}`);\r\n    }\r\n}\r\n\r\nfunction placeLabels(svgMake: SVGElementCreator, settings: LegendSettings, gradient: Gradient, container: Element): void {\r\n    if (settings.type === \"\" || settings.type[1] === \"n\") {\r\n        // no labels\r\n        return;\r\n    }\r\n\r\n    for (let stop of gradient.stops) {\r\n        if (!stop.showLegendLabel) {\r\n            continue;\r\n        }\r\n\r\n        let xCoord: number = settings.x;\r\n        let yCoord: number = settings.y;\r\n        let dy: number = 0.0;\r\n        let textAnchor: \"start\"|\"middle\"|\"end\" = \"start\";\r\n\r\n        if (settings.type[0] === \"h\") {\r\n            // horizontal scale\r\n            xCoord += stop.position * settings.length / legendLength;\r\n\r\n            textAnchor = \"middle\";\r\n            if (settings.type === \"hb\") {\r\n                yCoord += 2 * settings.width;\r\n                dy = 1.0;\r\n            }\r\n        } else if (settings.type[0] === \"v\") {\r\n            // vertical scale\r\n            yCoord += settings.length - (stop.position * settings.length / legendLength);\r\n            dy = 0.4;\r\n\r\n            if (settings.type === \"vl\") {\r\n                textAnchor = \"end\";\r\n            } else if (settings.type === \"vr\") {\r\n                textAnchor = \"start\";\r\n                xCoord += 2 * settings.width;\r\n            }\r\n        }\r\n\r\n        let label: SVGTextElement = svgMake.text();\r\n        container.appendChild(label);\r\n        label.setAttribute(\"class\", \"legend-label\");\r\n        label.setAttribute(\"x\", `${xCoord}`);\r\n        label.setAttribute(\"y\", `${yCoord}`);\r\n        label.setAttribute(\"dy\", `${dy}em`);\r\n        label.setAttribute(\"style\", `text-anchor:${textAnchor}`);\r\n        label.textContent = `${stop.position}`;\r\n    }\r\n}\r\n\r\nexport interface LegendSettings {\r\n    type: \"\"|\"hn\"|\"ha\"|\"hb\"|\"vn\"|\"vl\"|\"vr\";\r\n    x: number;\r\n    y: number;\r\n    length: number;\r\n    width: number;\r\n}\r\n","import { svgNamespace, xlinkNamespace } from \"./constants\";\r\nimport { deg2rad, halveCubicBezier, normalizeAngle, Point2D, polarToCartesian, unitVector } from \"./geometry\";\r\nimport { Gradient, GradientStop, gradientColorForValue } from \"./gradients\";\r\nimport { LegendSettings, placeLegend } from \"./legend\";\r\n\r\nexport function renderWeathermapInto(\r\n    elementCreator: SVGElementCreatorDOM, container: Node, config: WeathermapConfig, currentValues: MetricValueMap,\r\n    linkResolver: ((linkSettings: ObjectLinkSettings) => string|null)|null|undefined, addViewBox: boolean = false\r\n): SVGSVGElement {\r\n    // sort gradient stops\r\n    let sortedStops: GradientStop[] = config.gradient.stops\r\n        .slice()\r\n        .sort((l, r) => l.position - r.position);\r\n    let sortedGradient: Gradient = {\r\n        type: config.gradient.type,\r\n        stops: sortedStops\r\n    };\r\n\r\n    let state = new WeathermapRendererState(elementCreator, config, sortedGradient, currentValues);\r\n\r\n    initializeSVG(state, container, addViewBox);\r\n\r\n    // resolve links\r\n    if (linkResolver != null) {\r\n        state.nodeLinkUriBase = linkResolver(config.link.node);\r\n        state.edgeLinkUriBase = linkResolver(config.link.edge);\r\n    }\r\n\r\n    // emplacement\r\n    placeNodes(state);\r\n    placeEdges(state);\r\n    placeLabels(state);\r\n    placeLegend(state.make, config.legend, state.legendGroup!, state.defs!, sortedGradient, `${config.id}`);\r\n\r\n    return state.svg!;\r\n}\r\n\r\nfunction initializeSVG(state: WeathermapRendererState, container: Node, addViewBox: boolean = false): void {\r\n    // add SVG\r\n    state.svg = state.make.svg();\r\n    modifyStyle(state.svg, {\r\n        \"width\": `${state.config.canvasSize.width}px`,\r\n        \"height\": `${state.config.canvasSize.height}px`,\r\n    });\r\n    if (addViewBox) {\r\n        state.svg.setAttribute(\"viewBox\", `0 0 ${state.config.canvasSize.width} ${state.config.canvasSize.height}`);\r\n    }\r\n    container.appendChild(state.svg);\r\n\r\n    state.defs = state.make.defs();\r\n    state.svg.appendChild(state.defs);\r\n\r\n    state.legendGroup = state.make.g();\r\n    state.legendGroup.setAttribute(\"class\", \"legend\");\r\n    state.svg.appendChild(state.legendGroup);\r\n\r\n    state.edgeGroup = state.make.g();\r\n    state.edgeGroup.setAttribute(\"class\", \"edges\");\r\n    state.svg.appendChild(state.edgeGroup);\r\n\r\n    state.nodeGroup = state.make.g();\r\n    state.nodeGroup.setAttribute(\"class\", \"nodes\");\r\n    state.svg.appendChild(state.nodeGroup);\r\n\r\n    state.labelGroup = state.make.g();\r\n    state.labelGroup.setAttribute(\"class\", \"labels\");\r\n    state.svg.appendChild(state.labelGroup);\r\n}\r\n\r\nfunction placeNodes(state: WeathermapRendererState): void {\r\n    for (let node of state.config.weathermapNodes) {\r\n        state.nodeLabelToNode[node.label] = node;\r\n\r\n        let singleNodeGroup: SVGGElement = state.make.g();\r\n        maybeWrapIntoLink(state.make, state.nodeGroup!, singleNodeGroup, state.nodeLinkUriBase, node.linkParams);\r\n\r\n        let rect: SVGRectElement = state.make.rect();\r\n        singleNodeGroup.appendChild(rect);\r\n\r\n        setRectangleDimensions(rect, node.x, node.y, node.width, node.height);\r\n        modifyStyle(rect, {\r\n            \"stroke\": \"gray\",\r\n            \"stroke-width\": \"1px\",\r\n        });\r\n\r\n        let text: SVGTextElement = state.make.text();\r\n        singleNodeGroup.appendChild(text);\r\n\r\n        text.setAttribute(\"x\", `${(+node.x) + (+state.config.textOffsets.left)}`);\r\n        text.setAttribute(\"y\", `${(+node.y) + (+node.height) - state.config.textOffsets.bottom}`);\r\n        if (state.config.showNumbers && node.metricName != null) {\r\n            let value: string = (node.metricName in state.currentValues)\r\n                ? `${state.currentValues[node.metricName]}`\r\n                : \"?\"\r\n            ;\r\n            text.textContent = `${node.label} (${value})`;\r\n        } else {\r\n            text.textContent = node.label;\r\n        }\r\n\r\n        let currentValue: number|null = null;\r\n        if (!node.metricName) {\r\n            modifyStyle(rect, {\r\n                \"fill\": \"silver\",\r\n                \"stroke-dasharray\": state.config.unmeasuredDashArray,\r\n            });\r\n        } else if (node.metricName in state.currentValues) {\r\n            // color node by metric\r\n            currentValue = state.currentValues[node.metricName];\r\n            modifyStyle(rect, {\r\n                \"fill\": gradientColorForValue(state.sortedGradient, \"fillColor\", currentValue),\r\n            });\r\n        } else {\r\n            // no data\r\n            modifyStyle(text, {\r\n                \"fill\": \"white\",\r\n            });\r\n            modifyStyle(rect, {\r\n                \"fill\": \"black\",\r\n                \"stroke-dasharray\": state.config.noValueDashArray,\r\n            });\r\n        }\r\n\r\n        if (currentValue !== null) {\r\n            let titleElem: SVGTitleElement = state.make.title();\r\n            singleNodeGroup.insertBefore(titleElem, titleElem.firstChild);\r\n            titleElem.textContent = `${node.label} (${currentValue.toFixed(2)})`;\r\n        }\r\n    }\r\n}\r\n\r\nfunction placeEdges(state: WeathermapRendererState): void {\r\n    // place edges\r\n    for (let edge of state.config.weathermapEdges) {\r\n        let node1: WeathermapNode = state.nodeLabelToNode[edge.node1];\r\n        let node2: WeathermapNode = state.nodeLabelToNode[edge.node2];\r\n        if (!node1 || !node2) {\r\n            // TODO: output error\r\n            continue;\r\n        }\r\n\r\n        let singleEdgeGroup: SVGGElement = state.make.g();\r\n        maybeWrapIntoLink(state.make, state.edgeGroup!, singleEdgeGroup, state.edgeLinkUriBase, edge.linkParams);\r\n\r\n        let n1Center: Point2D = {\r\n            x: (+node1.x) + ((+node1.width) / 2),\r\n            y: (+node1.y) + ((+node1.height) / 2)\r\n        };\r\n        let n2Center: Point2D = {\r\n            x: (+node2.x) + ((+node2.width) / 2),\r\n            y: (+node2.y) + ((+node2.height) / 2)\r\n        };\r\n\r\n        // calculate bend (control points)\r\n        let control1: Point2D|null = null;\r\n        let control2: Point2D|null = null;\r\n        if (edge.bendDirection && edge.bendMagnitude) {\r\n            // warning: screen coordinates (flipped Y axis)!\r\n            let n1N2Angle: number = Math.atan2(n1Center.y - n2Center.y, n2Center.x - n1Center.x);\r\n            let n2N1Angle: number = Math.atan2(n2Center.y - n1Center.y, n1Center.x - n2Center.x);\r\n\r\n            let n1N2BendAngle: number = normalizeAngle(n1N2Angle + deg2rad(edge.bendDirection));\r\n            let n2N1BendAngle: number = normalizeAngle(n2N1Angle - deg2rad(edge.bendDirection));\r\n\r\n            let control1Offset: Point2D = polarToCartesian(n1N2BendAngle, edge.bendMagnitude);\r\n            let control2Offset: Point2D = polarToCartesian(n2N1BendAngle, edge.bendMagnitude);\r\n\r\n            control1 = {\r\n                x: (+n1Center.x) + control1Offset.x,\r\n                y: (+n1Center.y) - control1Offset.y\r\n            };\r\n            control2 = {\r\n                x: (+n2Center.x) + control2Offset.x,\r\n                y: (+n2Center.y) - control2Offset.y\r\n            };\r\n        }\r\n\r\n        if (edge.metric2Name) {\r\n            // two metrics are twice the fun\r\n            let\r\n                [, point1COut, point2CIn, point2, point2COut, point3CIn,]\r\n            =\r\n                halveCubicBezier(n1Center, control1, control2, n2Center)\r\n            ;\r\n\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                n1Center, point1COut, point2CIn, point2,\r\n                edge.metricName, edge.styleName,\r\n                `${edge.node1} \\u2192 ${edge.node2}`\r\n            );\r\n\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                point2, point2COut, point3CIn, n2Center,\r\n                edge.metric2Name, edge.styleName,\r\n                `${edge.node2} \\u2192 ${edge.node1}`\r\n            );\r\n        } else {\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                n1Center, control1, control2, n2Center,\r\n                edge.metricName, edge.styleName,\r\n                `${edge.node1} \\u2194 ${edge.node2}`\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nfunction placeLabels(state: WeathermapRendererState): void {\r\n    for (let label of state.config.weathermapLabels) {\r\n        let singleLabelGroup: SVGGElement = state.make.g();\r\n        state.labelGroup!.appendChild(singleLabelGroup);\r\n\r\n        let text: SVGTextElement = state.make.text();\r\n        singleLabelGroup.appendChild(text);\r\n\r\n        text.setAttribute(\"x\", `${+label.x}`);\r\n        text.setAttribute(\"y\", `${+label.y}`);\r\n        text.textContent = label.label;\r\n    }\r\n}\r\n\r\nfunction makeAndPlaceEdge(\r\n    state: WeathermapRendererState, singleEdgeGroup: SVGGElement, start: Point2D, control1: Point2D|null,\r\n    control2: Point2D|null, end: Point2D, metricName: string|null|undefined, edgeStyleName: string|null|undefined,\r\n    title: string|null|undefined\r\n): void {\r\n    let strokeWidths: number[] = [state.config.strokeWidth];\r\n    let edgeStyle: WeathermapStyle|null = getWeathermapStyle(state, edgeStyleName);\r\n    if (edgeStyle && edgeStyle.strokeWidthArray) {\r\n        let pieces: string[] = edgeStyle.strokeWidthArray.split(/[ ,]+/);\r\n        strokeWidths = pieces.map(p => Number.parseFloat(p));\r\n    }\r\n\r\n    if (strokeWidths.length % 2 !== 1) {\r\n        // like stroke-dasharray, double the elements\r\n        strokeWidths.push(...strokeWidths);\r\n    }\r\n\r\n    let offsetUnitVector: Point2D = {x: 0, y: 0};\r\n    if (strokeWidths.length > 1) {\r\n        // calculate an actual offset vector\r\n\r\n        // get the direction\r\n        let direction: Point2D = {\r\n            x: start.x - end.x,\r\n            y: start.y - end.y\r\n        };\r\n\r\n        // rotate 90°; that's the offset vector\r\n        let offsetVector: Point2D = {\r\n            x: direction.y,\r\n            y: -direction.x\r\n        };\r\n\r\n        // calculate unit vector\r\n        offsetUnitVector = unitVector(offsetVector);\r\n    }\r\n\r\n    let multistrokeGroup: SVGGElement = state.make.g();\r\n    singleEdgeGroup.appendChild(multistrokeGroup);\r\n    modifyStyle(multistrokeGroup, {\r\n        \"fill\": \"none\",\r\n    });\r\n\r\n    let currentValue: number|null = null;\r\n    if (metricName != null && metricName in state.currentValues) {\r\n        currentValue = state.currentValues[metricName];\r\n        modifyStyle(multistrokeGroup, {\r\n            \"stroke\": gradientColorForValue(state.sortedGradient, \"strokeColor\", currentValue)\r\n        });\r\n        modifyApplyingWeathermapStyle(state, multistrokeGroup, edgeStyle);\r\n    } else {\r\n        modifyStyle(multistrokeGroup, {\r\n            \"stroke\": \"black\",\r\n            \"stroke-dasharray\": state.config.noValueDashArray\r\n        });\r\n    }\r\n\r\n    if (title) {\r\n        let titleElem: SVGTitleElement = state.make.title();\r\n        multistrokeGroup.appendChild(titleElem);\r\n        titleElem.textContent = (currentValue === null)\r\n            ? title\r\n            : `${title} (${currentValue.toFixed(2)})`\r\n        ;\r\n    }\r\n\r\n    let totalStrokeWidth: number = strokeWidths.reduce((acc, cur) => acc + cur, 0);\r\n    let currentOffset: number = -totalStrokeWidth/2.0;\r\n    let isSpacing: boolean = true;\r\n    for (let strokeWidth of strokeWidths) {\r\n        isSpacing = !isSpacing;\r\n        if (isSpacing) {\r\n            currentOffset += strokeWidth;\r\n            continue;\r\n        }\r\n\r\n        // calculate offset\r\n        let xOffset: number = offsetUnitVector.x * (currentOffset + strokeWidth/2.0);\r\n        let yOffset: number = offsetUnitVector.y * (currentOffset + strokeWidth/2.0);\r\n\r\n        let strokeStart: Point2D = {\r\n            x: start.x + xOffset,\r\n            y: start.y + yOffset,\r\n        };\r\n        let strokeControl1: Point2D|null = (control1 == null) ? null : {\r\n            x: control1.x + xOffset,\r\n            y: control1.y + yOffset,\r\n        };\r\n        let strokeControl2: Point2D|null = (control2 == null) ? null : {\r\n            x: control2.x + xOffset,\r\n            y: control2.y + yOffset,\r\n        };\r\n        let strokeEnd: Point2D = {\r\n            x: end.x + xOffset,\r\n            y: end.y + yOffset,\r\n        };\r\n\r\n        // make the path\r\n        let path: SVGPathElement = state.make.path();\r\n        multistrokeGroup.appendChild(path);\r\n        if (strokeControl1 == null || strokeControl2 == null) {\r\n            path.setAttribute(\"d\",\r\n                `M ${strokeStart.x},${strokeStart.y} ` +\r\n                `L ${strokeEnd.x},${strokeEnd.y}`\r\n            );\r\n        } else {\r\n            path.setAttribute(\"d\",\r\n                `M ${strokeStart.x},${strokeStart.y} ` +\r\n                `C ${strokeControl1.x},${strokeControl1.y},${strokeControl2.x},${strokeControl2.y},${strokeEnd.x},${strokeEnd.y}`\r\n            );\r\n        }\r\n\r\n        // apply the specific stroke width\r\n        modifyStyle(path, {\r\n            \"stroke-width\": `${strokeWidth}`,\r\n        });\r\n\r\n        currentOffset += strokeWidth;\r\n    }\r\n\r\n    if (state.config.showNumbers) {\r\n        let midpoint: Point2D = halveCubicBezier(start, control1, control2, end)[3];\r\n        let valueString: string = (metricName != null && metricName in state.currentValues)\r\n            ? state.currentValues[metricName].toFixed(2)\r\n            : \"?\"\r\n        ;\r\n        let text: SVGTextElement = state.make.text();\r\n        singleEdgeGroup.appendChild(text);\r\n        text.setAttribute(\"x\", `${midpoint.x}`);\r\n        text.setAttribute(\"y\", `${midpoint.y}`);\r\n        text.textContent = valueString;\r\n    }\r\n}\r\n\r\nfunction maybeWrapIntoLink(\r\n    svgMake: SVGElementCreator, upperGroup: SVGGElement, singleObjectGroup: SVGGElement,\r\n    linkUriBase: string|null|undefined, objLinkParams: string|null|undefined\r\n): void {\r\n    if (linkUriBase != null) {\r\n        let objLinkUri: string = linkUriBase;\r\n        if (objLinkParams != null) {\r\n            objLinkUri += (objLinkUri.indexOf(\"?\") === -1)\r\n                ? \"?\"\r\n                : \"&\";\r\n\r\n            objLinkUri += objLinkParams;\r\n        }\r\n\r\n        let aElement: SVGAElement = svgMake.a();\r\n        upperGroup.appendChild(aElement);\r\n        aElement.setAttributeNS(xlinkNamespace, \"href\", objLinkUri);\r\n\r\n        aElement.appendChild(singleObjectGroup);\r\n    } else {\r\n        upperGroup.appendChild(singleObjectGroup);\r\n    }\r\n}\r\n\r\nexport function setRectangleDimensions(\r\n    element: SVGRectElement, x: number|string, y: number|string, width: number|string, height: number|string\r\n): void {\r\n    element.setAttribute(\"x\", `${x}`);\r\n    element.setAttribute(\"y\", `${y}`);\r\n    element.setAttribute(\"width\", `${width}`);\r\n    element.setAttribute(\"height\", `${height}`);\r\n}\r\n\r\nfunction modifyStyle(element: Element, newValues: object): void {\r\n    // parse style\r\n    let assembledStyle: StringMapping<string> = {};\r\n    if (element.hasAttribute(\"style\")) {\r\n        let styleVal: string|null = element.getAttribute(\"style\");\r\n        if (styleVal != null) {\r\n            for (let chunk of styleVal.split(\";\")) {\r\n                let index: number = chunk.indexOf(\":\");\r\n                if (index === -1) {\r\n                    continue;\r\n                }\r\n                let key: string = chunk.substr(0, index);\r\n                let value: string = chunk.substr(index + 1);\r\n                assembledStyle[key] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let key in newValues) {\r\n        if (newValues.hasOwnProperty(key)) {\r\n            if (newValues[key] === null) {\r\n                delete assembledStyle[key];\r\n            } else {\r\n                assembledStyle[key] = newValues[key];\r\n            }\r\n        }\r\n    }\r\n\r\n    let keyValuePairs: string[] = [];\r\n    for (let key in assembledStyle) {\r\n        if (assembledStyle.hasOwnProperty(key)) {\r\n            keyValuePairs.push(`${key}:${assembledStyle[key]}`);\r\n        }\r\n    }\r\n\r\n    let keyValueString: string = keyValuePairs.join(\";\");\r\n    element.setAttribute(\"style\", keyValueString);\r\n}\r\n\r\nfunction getWeathermapStyle(\r\n    state: WeathermapRendererState, styleName: string|null|undefined\r\n): WeathermapStyle|null {\r\n    if (!styleName) {\r\n        return null;\r\n    }\r\n\r\n    let style: WeathermapStyle|undefined = state.styleMap[styleName];\r\n    if (!style) {\r\n        return null;\r\n    }\r\n    return style;\r\n}\r\n\r\nfunction modifyApplyingWeathermapStyle(\r\n    state: WeathermapRendererState, element: Element, style: WeathermapStyle|null\r\n): void {\r\n    if (!style) {\r\n        return;\r\n    }\r\n\r\n    let styleProps: StringMapping<string> = {};\r\n    if (style.dashArray) {\r\n        styleProps[\"stroke-dasharray\"] = style.dashArray;\r\n    }\r\n    // style.strokeWidthArray is handled beforehand\r\n\r\n    modifyStyle(element, styleProps);\r\n}\r\n\r\n\r\nexport class WeathermapRendererState {\r\n    make: SVGElementCreator;\r\n    config: WeathermapConfig;\r\n    sortedGradient: Gradient;\r\n    currentValues: MetricValueMap;\r\n    nodeLabelToNode: LabelToNodeMap;\r\n    nodeLinkUriBase: string|null;\r\n    edgeLinkUriBase: string|null;\r\n    svg: SVGSVGElement|null;\r\n    defs: SVGDefsElement|null;\r\n    edgeGroup: SVGGElement|null;\r\n    nodeGroup: SVGGElement|null;\r\n    labelGroup: SVGGElement|null;\r\n    legendGroup: SVGGElement|null;\r\n    styleMap: NameToStyleMap;\r\n\r\n    constructor(\r\n        domCreator: SVGElementCreatorDOM, config: WeathermapConfig, sortedGradient: Gradient, currentValues: MetricValueMap\r\n    ) {\r\n        this.make = new SVGElementCreator(domCreator);\r\n        this.config = config;\r\n        this.sortedGradient = sortedGradient;\r\n        this.currentValues = currentValues;\r\n        this.nodeLabelToNode = {};\r\n        this.nodeLinkUriBase = null;\r\n        this.edgeLinkUriBase = null;\r\n        this.svg = null;\r\n        this.defs = null;\r\n        this.edgeGroup = null;\r\n        this.nodeGroup = null;\r\n        this.labelGroup = null;\r\n        this.legendGroup = null;\r\n\r\n        this.styleMap = {};\r\n        if (config.weathermapStyles) {\r\n            for (let style of config.weathermapStyles) {\r\n                this.styleMap[style.name] = style;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class SVGElementCreator {\r\n    maker: SVGElementCreatorDOM;\r\n\r\n    constructor(maker: SVGElementCreatorDOM) { this.maker = maker; }\r\n\r\n    a() { return <SVGAElement>this.maker.createElementNS(svgNamespace, \"a\"); }\r\n    defs() { return <SVGDefsElement>this.maker.createElementNS(svgNamespace, \"defs\"); }\r\n    g() { return <SVGGElement>this.maker.createElementNS(svgNamespace, \"g\"); }\r\n    linearGradient() { return <SVGLinearGradientElement>this.maker.createElementNS(svgNamespace, \"linearGradient\"); }\r\n    path() { return <SVGPathElement>this.maker.createElementNS(svgNamespace, \"path\"); }\r\n    rect() { return <SVGRectElement>this.maker.createElementNS(svgNamespace, \"rect\"); }\r\n    stop() { return <SVGStopElement>this.maker.createElementNS(svgNamespace, \"stop\"); }\r\n    svg() { return <SVGSVGElement>this.maker.createElementNS(svgNamespace, \"svg\"); }\r\n    text() { return <SVGTextElement>this.maker.createElementNS(svgNamespace, \"text\"); }\r\n    title() { return <SVGTitleElement>this.maker.createElementNS(svgNamespace, \"title\"); }\r\n}\r\n\r\nexport interface SVGElementCreatorDOM {\r\n    createElementNS(namespaceURI: string, qualifiedName: string): Element;\r\n}\r\n\r\ninterface PositionableTextElement {\r\n    label: string;\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport interface WeathermapNode extends PositionableTextElement {\r\n    width: number;\r\n    height: number;\r\n    metricName?: string|null;\r\n    linkParams?: string;\r\n}\r\n\r\nexport interface WeathermapEdge {\r\n    node1: string;\r\n    node2: string;\r\n    bendDirection?: number;\r\n    bendMagnitude?: number;\r\n    metricName?: string;\r\n    metric2Name?: string|null;\r\n    linkParams?: string;\r\n    styleName?: string;\r\n}\r\n\r\nexport interface WeathermapLabel extends PositionableTextElement {\r\n}\r\n\r\nexport interface WeathermapStyle {\r\n    name: string;\r\n    strokeWidthArray?: string;\r\n    dashArray?: string;\r\n}\r\n\r\ninterface LinkSettings {\r\n    node: ObjectLinkSettings;\r\n    edge: ObjectLinkSettings;\r\n}\r\n\r\nexport interface StringMapping<V> {\r\n    [key: string]: V;\r\n}\r\n\r\nexport type LabelToNodeMap = StringMapping<WeathermapNode>;\r\nexport type MetricValueMap = StringMapping<number>;\r\nexport type NameToStyleMap = StringMapping<WeathermapStyle>;\r\n\r\nexport interface ObjectLinkSettings {\r\n    type: \"none\"|\"dashboard\"|\"absolute\";\r\n    dashboard: string|null;\r\n    dashUri: string|null;\r\n    absoluteUri: string|null;\r\n}\r\n\r\nexport interface WeathermapDefaultConfig {\r\n    weathermapEdges: WeathermapEdge[];\r\n    weathermapNodes: WeathermapNode[];\r\n    weathermapLabels: WeathermapLabel[];\r\n    weathermapStyles: WeathermapStyle[];\r\n    canvasSize: { width: number; height: number; };\r\n    textOffsets: { left: number; bottom: number; };\r\n    showNumbers: boolean;\r\n    valueName: \"max\"|\"min\"|\"avg\"|\"current\"|\"total\";\r\n    nullPointMode: \"connected\"|\"null\"|\"null as zero\";\r\n    strokeWidth: number;\r\n    gradient: Gradient;\r\n    legend: LegendSettings;\r\n    link: LinkSettings;\r\n    noValueDashArray: string;\r\n    unmeasuredDashArray: string;\r\n}\r\n\r\nexport interface WeathermapConfig extends WeathermapDefaultConfig {\r\n    id: number;\r\n}\r\n","import { MetricsPanelCtrl } from 'grafana/app/plugins/sdk';\r\nimport { editorPath, nodeEditorPath, edgeEditorPath, labelEditorPath, styleEditorPath } from \"./properties\";\r\nimport {\r\n    renderWeathermapInto,\r\n    WeathermapConfig,\r\n    WeathermapDefaultConfig,\r\n    WeathermapNode,\r\n    WeathermapEdge,\r\n    WeathermapLabel,\r\n    WeathermapStyle,\r\n    ObjectLinkSettings,\r\n    StringMapping\r\n} from \"./svg-weathermap/weathermap\";\r\nimport {\r\n    GradientStop\r\n} from \"./svg-weathermap/gradients\";\r\nimport _ from \"lodash\";\r\nimport TimeSeries from \"grafana/app/core/time_series2\";\r\n\r\nconst panelDefaults: WeathermapDefaultConfig = {\r\n    // data\r\n    weathermapNodes: [],\r\n    weathermapEdges: [],\r\n    weathermapLabels: [],\r\n    weathermapStyles: [],\r\n    canvasSize: {\r\n        width: 800,\r\n        height: 600\r\n    },\r\n    textOffsets: {\r\n        left: 5,\r\n        bottom: 5\r\n    },\r\n    showNumbers: false,\r\n    valueName: \"max\",\r\n    nullPointMode: \"connected\",\r\n    strokeWidth: 1,\r\n    gradient: {\r\n        type: \"steps\",\r\n        stops: []\r\n    },\r\n    legend: {\r\n        type: \"\",\r\n        x: 0,\r\n        y: 0,\r\n        length: 100,\r\n        width: 5\r\n    },\r\n    link: {\r\n        node: {\r\n            type: \"none\",\r\n            absoluteUri: null,\r\n            dashboard: null,\r\n            dashUri: null\r\n        },\r\n        edge: {\r\n            type: \"none\",\r\n            absoluteUri: null,\r\n            dashboard: null,\r\n            dashUri: null\r\n        }\r\n    },\r\n    noValueDashArray: \"4 4\",\r\n    unmeasuredDashArray: \"4 2\",\r\n};\r\n\r\nexport class WeathermapCtrl extends MetricsPanelCtrl {\r\n    static templateUrl: string;\r\n    currentValues: {[key: string]: number;};\r\n    currentSeries: object;\r\n\r\n    panel: WeathermapConfig;\r\n\r\n    searchDashboards: (queryStr: string, callback: (matches: string[]) => any) => void;\r\n\r\n    /** @ngInject **/\r\n    constructor($scope: any, $injector: any, private backendSrv: any) {\r\n        super($scope, $injector);\r\n        _.defaultsDeep(this.panel, panelDefaults);\r\n\r\n        this.currentValues = {};\r\n\r\n        this.events.on(\"init-edit-mode\", this.onInitEditMode.bind(this));\r\n        this.events.on(\"data-received\", this.onDataReceived.bind(this));\r\n        this.events.on(\"data-snapshot-load\", this.onDataSnapshotLoad.bind(this));\r\n\r\n        this.searchDashboards = function (queryStr: string, callback: (matches: string[]) => any): void {\r\n            backendSrv.search({query: queryStr}).then(hits => {\r\n                let dashboards: any[] = _.map(hits, dash => dash.title);\r\n                callback(dashboards);\r\n            });\r\n        };\r\n    }\r\n\r\n    onInitEditMode(): void {\r\n        this.addEditorTab(\"Options\", editorPath, 2);\r\n        this.addEditorTab(\"Nodes\", nodeEditorPath, 3);\r\n        this.addEditorTab(\"Edges\", edgeEditorPath, 4);\r\n        this.addEditorTab(\"Labels\", labelEditorPath, 5);\r\n        this.addEditorTab(\"Styles\", styleEditorPath, 6);\r\n    }\r\n\r\n    onDataReceived(dataList: any): void {\r\n        this.currentSeries = dataList.map(this.seriesHandler.bind(this));\r\n        this.currentValues = this.parseSeries(this.currentSeries);\r\n\r\n        this.render();\r\n    }\r\n\r\n    seriesHandler(seriesData: any): TimeSeries {\r\n        let series = new TimeSeries({\r\n            datapoints: seriesData.datapoints,\r\n            alias: seriesData.target\r\n        });\r\n        series.getFlotPairs(this.panel.nullPointMode);\r\n        return series;\r\n    }\r\n\r\n    parseSeries(series: any): StringMapping<number> {\r\n        let targetToValue: StringMapping<number> = {};\r\n        for (let ser of series) {\r\n            targetToValue[ser.alias] = ser.stats[this.panel.valueName];\r\n        }\r\n        return targetToValue;\r\n    }\r\n\r\n    onDataSnapshotLoad(snapshotData: any): void {\r\n        this.onDataReceived(snapshotData);\r\n    }\r\n\r\n    addWeathermapNode(node?: WeathermapNode): void {\r\n        this.panel.weathermapNodes.push(node || <WeathermapNode>{});\r\n    }\r\n    removeWeathermapNode(node: WeathermapNode): void {\r\n        this.panel.weathermapNodes = _.without(this.panel.weathermapNodes, node);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapEdge(edge?: WeathermapEdge): void {\r\n        this.panel.weathermapEdges.push(edge || <WeathermapEdge>{});\r\n    }\r\n    removeWeathermapEdge(edge: WeathermapEdge): void {\r\n        this.panel.weathermapEdges = _.without(this.panel.weathermapEdges, edge);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapLabel(label?: WeathermapLabel): void {\r\n        this.panel.weathermapLabels.push(label || <WeathermapLabel>{});\r\n    }\r\n    removeWeathermapLabel(label: WeathermapLabel): void {\r\n        this.panel.weathermapLabels = _.without(this.panel.weathermapLabels, label);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapStyle(style?: WeathermapStyle): void {\r\n        this.panel.weathermapStyles.push(style || <WeathermapStyle>{});\r\n    }\r\n    removeWeathermapStyle(style: WeathermapStyle): void {\r\n        this.panel.weathermapStyles = _.without(this.panel.weathermapStyles, style);\r\n        this.refresh();\r\n    }\r\n\r\n    addGradientStop(stop?: GradientStop): void {\r\n        this.panel.gradient.stops.push(stop || <GradientStop>{});\r\n    }\r\n    onGradientStopStrokeColorChange(stopIndex: number): (color: string) => void {\r\n        return (color: string) => {\r\n            this.panel.gradient.stops[stopIndex].strokeColor = color;\r\n            this.refresh();\r\n        };\r\n    }\r\n    onGradientStopFillColorChange(stopIndex: number): (color: string) => void {\r\n        return (color: string) => {\r\n            this.panel.gradient.stops[stopIndex].fillColor = color;\r\n            this.refresh();\r\n        };\r\n    }\r\n    removeGradientStop(stop: GradientStop): void {\r\n        this.panel.gradient.stops = _.without(this.panel.gradient.stops, stop);\r\n        this.refresh();\r\n    }\r\n\r\n    dashboardChanged(link: ObjectLinkSettings): void {\r\n        this.backendSrv.search({query: link.dashboard}).then((hits) => {\r\n            let dashboard: any = _.find(hits, {title: link.dashboard});\r\n            if (dashboard) {\r\n                link.dashUri = dashboard.url;\r\n            }\r\n        });\r\n    }\r\n\r\n    link(_scope: any, elems: HTMLElement[], _attrs: any, ctrl: any): void {\r\n        this.events.on(\"render\", () => this.renderThat(elems[0], ctrl));\r\n    }\r\n\r\n    renderThat(topElem: HTMLElement, _ctrl: any): void {\r\n        // find weathermap div\r\n        let elem: Element|null = topElem.querySelector(\"div.weathermap\");\r\n        if (elem === null) {\r\n            // oh well\r\n            return;\r\n        }\r\n\r\n        // filicide\r\n        while (elem.lastChild) {\r\n            elem.removeChild(elem.lastChild);\r\n        }\r\n\r\n        // do it\r\n        renderWeathermapInto(document, elem, this.panel, this.currentValues, WeathermapCtrl.resolveLink);\r\n    }\r\n\r\n    static resolveLink(objLink: ObjectLinkSettings): string|null {\r\n        if (objLink.type === \"absolute\" && objLink.absoluteUri) {\r\n            return objLink.absoluteUri;\r\n        } else if (objLink.type === \"dashboard\" && objLink.dashUri) {\r\n            let url = new URL(window.location.href);\r\n            let oldParams: StringMapping<string> = getSearchParams(url);\r\n            let params: string[] = [];\r\n\r\n            if (oldParams.from) {\r\n                params.push(`from=${encodeURIComponent(oldParams.from)}`);\r\n            }\r\n\r\n            if (oldParams.to) {\r\n                params.push(`to=${encodeURIComponent(oldParams.to)}`);\r\n            }\r\n\r\n            let paramSuffix: string = \"\";\r\n            if (params.length > 0) {\r\n                paramSuffix = \"?\" + params.join(\"&\");\r\n            }\r\n            return `${objLink.dashUri}${paramSuffix}`;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nWeathermapCtrl.templateUrl = \"partials/module.html\";\r\n\r\nfunction getSearchParams(url: URL): StringMapping<string> {\r\n    let search: string = url.search;\r\n    while (search.startsWith(\"?\")) {\r\n        search = search.substr(1);\r\n    }\r\n\r\n    let params: StringMapping<string> = {};\r\n    if (search.length > 0) {\r\n        let pairs: string[] = search.split(\"&\");\r\n        for (let pair of pairs) {\r\n            let keyValueMatch: RegExpMatchArray|null = pair.match(/^([^=]*)(?:=(.*))?$/);\r\n            if (keyValueMatch === null) {\r\n                continue;\r\n            }\r\n\r\n            let key: string = keyValueMatch[1];\r\n            let value: string = keyValueMatch[2];\r\n            if (key !== undefined && value !== undefined) {\r\n                params[decodeURIComponent(key)] = decodeURIComponent(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return params;\r\n}\r\n","export const\r\n    pluginName: string = \"ravualhemio-weathermap-panel\",\r\n    editorPath: string = `public/plugins/${pluginName}/partials/editor.html`,\r\n    nodeEditorPath: string = `public/plugins/${pluginName}/partials/nodeEditor.html`,\r\n    edgeEditorPath: string = `public/plugins/${pluginName}/partials/edgeEditor.html`,\r\n    labelEditorPath: string = `public/plugins/${pluginName}/partials/labelEditor.html`,\r\n    styleEditorPath: string = `public/plugins/${pluginName}/partials/styleEditor.html`;\r\n"],"sourceRoot":""}