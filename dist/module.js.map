{"version":3,"file":"module.js","mappings":"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","sources":["webpack:///external amd \"app/core/time_series2\"","webpack:///external amd \"app/plugins/sdk\"","webpack:///external amd \"lodash\"","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./properties.ts","webpack:///./svg-weathermap/constants.ts","webpack:///./svg-weathermap/geometry.ts","webpack:///./svg-weathermap/gradients.ts","webpack:///./svg-weathermap/legend.ts","webpack:///./svg-weathermap/weathermap.ts","webpack:///./weathermapControl.ts"],"sourcesContent":["module.exports = __WEBPACK_EXTERNAL_MODULE__340__;","module.exports = __WEBPACK_EXTERNAL_MODULE__735__;","module.exports = __WEBPACK_EXTERNAL_MODULE__980__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const\r\n    pluginName: string = \"ravualhemio-weathermap-panel\",\r\n    editorPath: string = `public/plugins/${pluginName}/partials/editor.html`,\r\n    nodeEditorPath: string = `public/plugins/${pluginName}/partials/nodeEditor.html`,\r\n    edgeEditorPath: string = `public/plugins/${pluginName}/partials/edgeEditor.html`,\r\n    labelEditorPath: string = `public/plugins/${pluginName}/partials/labelEditor.html`,\r\n    styleEditorPath: string = `public/plugins/${pluginName}/partials/styleEditor.html`;\r\n","export const svgNamespace: string = \"http://www.w3.org/2000/svg\";\r\nexport const xlinkNamespace: string = \"http://www.w3.org/1999/xlink\";\r\n","export function midpoint(point1: Point2D, point2: Point2D): Point2D {\r\n    return {\r\n        x: (point1.x + point2.x)/2.0,\r\n        y: (point1.y + point2.y)/2.0\r\n    };\r\n}\r\n\r\nexport function halveCubicBezier(\r\n    point1: Point2D, control1: Point2D|null, control2: Point2D|null, point2: Point2D\r\n): [Point2D, Point2D, Point2D, Point2D, Point2D, Point2D, Point2D] {\r\n    if (control1 === null) {\r\n        if (control2 === null) {\r\n            // naïveté!\r\n            let straightMidpoint: Point2D = midpoint(point1, point2);\r\n            return [point1, point1, straightMidpoint, straightMidpoint, straightMidpoint, point2, point2];\r\n        }\r\n\r\n        control1 = point1;\r\n    }\r\n    if (control2 === null) {\r\n        control2 = point2;\r\n    }\r\n\r\n    let m1: Point2D = midpoint(point1, control1);\r\n    let m2: Point2D = midpoint(control1, control2);\r\n    let m3: Point2D = midpoint(control2, point2);\r\n\r\n    let q1: Point2D = midpoint(m1, m2);\r\n    let q2: Point2D = midpoint(m2, m3);\r\n\r\n    let o: Point2D = midpoint(q1, q2);\r\n\r\n    return [point1, m1, q1, o, q2, m3, point2];\r\n}\r\n\r\nexport function polarToCartesian(angleRadians: number|null, length: number|null): Point2D {\r\n    if (angleRadians === null) {\r\n        angleRadians = 0;\r\n    }\r\n    if (length === null) {\r\n        length = 0;\r\n    }\r\n\r\n    return {\r\n        x: length * Math.cos(angleRadians),\r\n        y: length * Math.sin(angleRadians)\r\n    };\r\n}\r\n\r\nexport function normalizeAngle(angleRadians: number): number {\r\n    while (angleRadians <= -Math.PI) {\r\n        angleRadians += 2 * Math.PI;\r\n    }\r\n    while (angleRadians > Math.PI) {\r\n        angleRadians -= 2 * Math.PI;\r\n    }\r\n    return angleRadians;\r\n}\r\n\r\nexport function unitVector(vector: Point2D): Point2D {\r\n    let euclidNorm: number = Math.sqrt(vector.x*vector.x + vector.y*vector.y);\r\n    return {\r\n        x: vector.x / euclidNorm,\r\n        y: vector.y / euclidNorm\r\n    };\r\n}\r\n\r\nexport function deg2rad(angleDegrees: number): number {\r\n    return angleDegrees * Math.PI / 180;\r\n}\r\n\r\nexport function rad2deg(angleRadians: number): number {\r\n    return angleRadians * 180 / Math.PI;\r\n}\r\n\r\nexport interface Point2D {\r\n    x: number;\r\n    y: number;\r\n}\r\n","const emergencyColor: string = \"pink\";\r\n\r\nexport function gradientColorForValue(gradient: Gradient, colorType: keyof GradientStop, value: number): string {\r\n    if (gradient.type === \"linear\") {\r\n        return linearColorForValue(gradient.stops, colorType, value);\r\n    } else if (gradient.type === \"steps\") {\r\n        return stepColorForValue(gradient.stops, colorType, value);\r\n    }\r\n    return emergencyColor;\r\n}\r\n\r\nfunction linearColorForValue(stops: GradientStop[], colorType: keyof GradientStop, value: number): string {\r\n    if (stops.length === 0) {\r\n        return emergencyColor;\r\n    }\r\n\r\n    let lastStop: GradientStop = stops[stops.length-1];\r\n    let r: number = 0.0, g: number = 0.0, b: number = 0.0;\r\n    if (value < stops[0].position) {\r\n        return `${stops[0][colorType]}`;\r\n    } else if (value >= lastStop.position) {\r\n        return `${lastStop[colorType]}`;\r\n    } else {\r\n        let foundMatch: boolean = false;\r\n        for (let i: number = 0; i < stops.length-1; ++i) {\r\n            if (value >= stops[i].position && value < stops[i+1].position) {\r\n                // found!\r\n\r\n                let posFrom: number = stops[i].position;\r\n                let rFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(1, 2), 16);\r\n                let gFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(3, 2), 16);\r\n                let bFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(5, 2), 16);\r\n\r\n                let posTo: number = stops[i+1].position;\r\n                let rTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(1, 2), 16);\r\n                let gTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(3, 2), 16);\r\n                let bTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(5, 2), 16);\r\n\r\n                r = lerp(value, posFrom, posTo, rFrom, rTo);\r\n                g = lerp(value, posFrom, posTo, gFrom, gTo);\r\n                b = lerp(value, posFrom, posTo, bFrom, bTo);\r\n\r\n                foundMatch = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!foundMatch) {\r\n            return emergencyColor;\r\n        }\r\n    }\r\n\r\n    return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;\r\n}\r\n\r\nfunction stepColorForValue(stops: GradientStop[], colorType: keyof GradientStop, value: number): string {\r\n    if (stops.length === 0) {\r\n        return emergencyColor;\r\n    }\r\n\r\n    let lastStop: GradientStop = stops[stops.length-1];\r\n    if (value < stops[0].position) {\r\n        return `${stops[0][colorType]}`;\r\n    } else if (value >= lastStop.position) {\r\n        return `${lastStop[colorType]}`;\r\n    } else {\r\n        for (let i: number = 0; i < stops.length-1; ++i) {\r\n            if (value >= stops[i].position && value < stops[i+1].position) {\r\n                return `${stops[i][colorType]}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    return emergencyColor;\r\n}\r\n\r\nfunction lerp(value: number, sourceMin: number, sourceMax: number, targetMin: number, targetMax: number): number {\r\n    if (targetMin === targetMax) {\r\n        return targetMin;\r\n    }\r\n\r\n    if (value < sourceMin) {\r\n        value = sourceMin;\r\n    }\r\n    if (value > sourceMax) {\r\n        value = sourceMax;\r\n    }\r\n\r\n    let terp: number = (value - sourceMin) / (sourceMax - sourceMin);\r\n    return targetMin + terp * (targetMax - targetMin);\r\n}\r\n\r\n\r\nexport interface GradientStop {\r\n    position: number;\r\n    strokeColor: string;\r\n    fillColor: string;\r\n    showLegendLabel: boolean;\r\n}\r\n\r\nexport interface Gradient {\r\n    type: \"steps\"|\"linear\";\r\n    stops: GradientStop[];\r\n}\r\n","import { Gradient, GradientStop } from \"./gradients\";\r\nimport { SVGElementCreator, setRectangleDimensions } from \"./weathermap\";\r\n\r\nconst legendLength: number = 100;\r\nconst legendWidth: number = 5;\r\n// (let the container apply any transformations)\r\n\r\nexport function placeLegend(\r\n    svgMake: SVGElementCreator, settings: LegendSettings, container: Element, defs: SVGDefsElement, gradient: Gradient,\r\n    weathermapID?: string|null\r\n): void {\r\n    let transform: string = \"\";\r\n\r\n    if (settings.type === \"\") {\r\n        // no legend\r\n        return;\r\n    }\r\n\r\n    // draw stroke-color legend\r\n    let strokeLegendContainer: SVGGElement = svgMake.g();\r\n    container.appendChild(strokeLegendContainer);\r\n    strokeLegendContainer.setAttribute(\"class\", \"stroke-legend\");\r\n    if (settings.type[0] === \"h\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y})`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    } else if (settings.type[0] === \"v\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y + settings.length})`\r\n            + ` rotate(-90)`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    }\r\n    strokeLegendContainer.setAttribute(\"transform\", transform);\r\n    drawLegend(svgMake, gradient, \"strokeColor\", strokeLegendContainer, defs, weathermapID);\r\n\r\n    // draw fill-color legend\r\n    let fillLegendContainer: SVGGElement = svgMake.g();\r\n    container.appendChild(fillLegendContainer);\r\n    strokeLegendContainer.setAttribute(\"class\", \"fill-legend\");\r\n    if (settings.type[0] === \"h\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y + settings.width})`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    } else if (settings.type[0] === \"v\") {\r\n        transform =\r\n            `translate(${settings.x + settings.width} ${settings.y + settings.length})`\r\n            + ` rotate(-90)`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    }\r\n    fillLegendContainer.setAttribute(\"transform\", transform);\r\n    drawLegend(svgMake, gradient, \"fillColor\", fillLegendContainer, defs, weathermapID);\r\n\r\n    // draw legend labels\r\n    placeLabels(svgMake, settings, gradient, container);\r\n}\r\n\r\nfunction drawLegend(\r\n    svgMake: SVGElementCreator, gradient: Gradient, colorType: keyof GradientStop, container: SVGElement,\r\n    defs: SVGDefsElement, weathermapID?: string|null\r\n): void {\r\n    if (gradient.type === \"linear\") {\r\n        let legendGradientName: string = `WeathermapLegendGradient-${colorType}`;\r\n        if (weathermapID != null) {\r\n            legendGradientName = `${legendGradientName}-${weathermapID}`;\r\n        }\r\n\r\n        let svgGrad: SVGLinearGradientElement = svgMake.linearGradient();\r\n        defs.appendChild(svgGrad);\r\n        svgGrad.setAttribute(\"id\", legendGradientName);\r\n\r\n        for (let stop of gradient.stops) {\r\n            let svgStop: SVGStopElement = svgMake.stop();\r\n            svgGrad.appendChild(svgStop);\r\n            svgStop.setAttribute(\"offset\", `${stop.position}%`);\r\n            svgStop.setAttribute(\"stop-color\", `${stop[colorType]}`);\r\n        }\r\n\r\n        let svgRect: SVGRectElement = svgMake.rect();\r\n        container.appendChild(svgRect);\r\n        setRectangleDimensions(svgRect, 0, 0, legendLength, legendWidth);\r\n        svgRect.setAttribute(\"style\", `fill:url(#${legendGradientName})`);\r\n    } else if (gradient.type === \"steps\") {\r\n        for (let i: number = 1; i < gradient.stops.length; ++i) {\r\n            let rect: SVGRectElement = svgMake.rect();\r\n            container.appendChild(rect);\r\n\r\n            setRectangleDimensions(rect,\r\n                gradient.stops[i-1].position,\r\n                0,\r\n                gradient.stops[i].position - gradient.stops[i-1].position,\r\n                legendWidth\r\n            );\r\n            rect.setAttribute(\"style\", `fill:${gradient.stops[i-1][colorType]}`);\r\n        }\r\n        let rect: SVGRectElement = svgMake.rect();\r\n        container.appendChild(rect);\r\n        setRectangleDimensions(rect,\r\n            gradient.stops[gradient.stops.length-1].position,\r\n            0,\r\n            100 - gradient.stops[gradient.stops.length-1].position,\r\n            legendWidth\r\n        );\r\n        rect.setAttribute(\"style\", `fill:${gradient.stops[gradient.stops.length-1][colorType]}`);\r\n    }\r\n}\r\n\r\nfunction placeLabels(svgMake: SVGElementCreator, settings: LegendSettings, gradient: Gradient, container: Element): void {\r\n    if (settings.type === \"\" || settings.type[1] === \"n\") {\r\n        // no labels\r\n        return;\r\n    }\r\n\r\n    for (let stop of gradient.stops) {\r\n        if (!stop.showLegendLabel) {\r\n            continue;\r\n        }\r\n\r\n        let xCoord: number = settings.x;\r\n        let yCoord: number = settings.y;\r\n        let dy: number = 0.0;\r\n        let textAnchor: \"start\"|\"middle\"|\"end\" = \"start\";\r\n\r\n        if (settings.type[0] === \"h\") {\r\n            // horizontal scale\r\n            xCoord += stop.position * settings.length / legendLength;\r\n\r\n            textAnchor = \"middle\";\r\n            if (settings.type === \"hb\") {\r\n                yCoord += 2 * settings.width;\r\n                dy = 1.0;\r\n            }\r\n        } else if (settings.type[0] === \"v\") {\r\n            // vertical scale\r\n            yCoord += settings.length - (stop.position * settings.length / legendLength);\r\n            dy = 0.4;\r\n\r\n            if (settings.type === \"vl\") {\r\n                textAnchor = \"end\";\r\n            } else if (settings.type === \"vr\") {\r\n                textAnchor = \"start\";\r\n                xCoord += 2 * settings.width;\r\n            }\r\n        }\r\n\r\n        let label: SVGTextElement = svgMake.text();\r\n        container.appendChild(label);\r\n        label.setAttribute(\"class\", \"legend-label\");\r\n        label.setAttribute(\"x\", `${xCoord}`);\r\n        label.setAttribute(\"y\", `${yCoord}`);\r\n        label.setAttribute(\"dy\", `${dy}em`);\r\n        label.setAttribute(\"style\", `text-anchor:${textAnchor}`);\r\n        label.textContent = `${stop.position}`;\r\n    }\r\n}\r\n\r\nexport interface LegendSettings {\r\n    type: \"\"|\"hn\"|\"ha\"|\"hb\"|\"vn\"|\"vl\"|\"vr\";\r\n    x: number;\r\n    y: number;\r\n    length: number;\r\n    width: number;\r\n}\r\n","import { svgNamespace, xlinkNamespace } from \"./constants\";\r\nimport { deg2rad, halveCubicBezier, normalizeAngle, Point2D, polarToCartesian, unitVector } from \"./geometry\";\r\nimport { Gradient, GradientStop, gradientColorForValue } from \"./gradients\";\r\nimport { LegendSettings, placeLegend } from \"./legend\";\r\n\r\nexport function renderWeathermapInto(\r\n    elementCreator: SVGElementCreatorDOM, container: Node, config: WeathermapConfig, currentValues: MetricValueMap,\r\n    linkResolver: ((linkSettings: ObjectLinkSettings) => string|null)|null|undefined, addViewBox: boolean = false\r\n): SVGSVGElement {\r\n    // sort gradient stops\r\n    let sortedStops: GradientStop[] = config.gradient.stops\r\n        .slice()\r\n        .sort((l, r) => l.position - r.position);\r\n    let sortedGradient: Gradient = {\r\n        type: config.gradient.type,\r\n        stops: sortedStops\r\n    };\r\n\r\n    let state = new WeathermapRendererState(elementCreator, config, sortedGradient, currentValues);\r\n\r\n    initializeSVG(state, container, addViewBox);\r\n\r\n    // resolve links\r\n    if (linkResolver != null) {\r\n        state.nodeLinkUriBase = linkResolver(config.link.node);\r\n        state.edgeLinkUriBase = linkResolver(config.link.edge);\r\n    }\r\n\r\n    // emplacement\r\n    placeNodes(state);\r\n    placeEdges(state);\r\n    placeLabels(state);\r\n    placeLegend(state.make, config.legend, state.legendGroup!, state.defs!, sortedGradient, `${config.id}`);\r\n\r\n    return state.svg!;\r\n}\r\n\r\nfunction initializeSVG(state: WeathermapRendererState, container: Node, addViewBox: boolean = false): void {\r\n    // add SVG\r\n    state.svg = state.make.svg();\r\n    modifyStyle(state.svg, {\r\n        \"width\": `${state.config.canvasSize.width}px`,\r\n        \"height\": `${state.config.canvasSize.height}px`,\r\n    });\r\n    if (addViewBox) {\r\n        state.svg.setAttribute(\"viewBox\", `0 0 ${state.config.canvasSize.width} ${state.config.canvasSize.height}`);\r\n    }\r\n    container.appendChild(state.svg);\r\n\r\n    state.defs = state.make.defs();\r\n    state.svg.appendChild(state.defs);\r\n\r\n    state.legendGroup = state.make.g();\r\n    state.legendGroup.setAttribute(\"class\", \"legend\");\r\n    state.svg.appendChild(state.legendGroup);\r\n\r\n    state.edgeGroup = state.make.g();\r\n    state.edgeGroup.setAttribute(\"class\", \"edges\");\r\n    state.svg.appendChild(state.edgeGroup);\r\n\r\n    state.nodeGroup = state.make.g();\r\n    state.nodeGroup.setAttribute(\"class\", \"nodes\");\r\n    state.svg.appendChild(state.nodeGroup);\r\n\r\n    state.labelGroup = state.make.g();\r\n    state.labelGroup.setAttribute(\"class\", \"labels\");\r\n    state.svg.appendChild(state.labelGroup);\r\n}\r\n\r\nfunction placeNodes(state: WeathermapRendererState): void {\r\n    for (let node of state.config.weathermapNodes) {\r\n        state.nodeLabelToNode[node.label] = node;\r\n\r\n        let singleNodeGroup: SVGGElement = state.make.g();\r\n        maybeWrapIntoLink(state.make, state.nodeGroup!, singleNodeGroup, state.nodeLinkUriBase, node.linkParams);\r\n\r\n        let rect: SVGRectElement = state.make.rect();\r\n        singleNodeGroup.appendChild(rect);\r\n\r\n        setRectangleDimensions(rect, node.x, node.y, node.width, node.height);\r\n        modifyStyle(rect, {\r\n            \"stroke\": \"gray\",\r\n            \"stroke-width\": \"1px\",\r\n        });\r\n\r\n        let text: SVGTextElement = state.make.text();\r\n        singleNodeGroup.appendChild(text);\r\n\r\n        text.setAttribute(\"x\", `${(+node.x) + (+state.config.textOffsets.left)}`);\r\n        text.setAttribute(\"y\", `${(+node.y) + (+node.height) - state.config.textOffsets.bottom}`);\r\n        if (state.config.showNumbers && node.metricName != null) {\r\n            let value: string = (node.metricName in state.currentValues)\r\n                ? `${state.currentValues[node.metricName]}`\r\n                : \"?\"\r\n            ;\r\n            text.textContent = `${node.label} (${value})`;\r\n        } else {\r\n            text.textContent = node.label;\r\n        }\r\n\r\n        let currentValue: number|null = null;\r\n        if (!node.metricName) {\r\n            modifyStyle(rect, {\r\n                \"fill\": \"silver\",\r\n                \"stroke-dasharray\": state.config.unmeasuredDashArray,\r\n            });\r\n        } else if (node.metricName in state.currentValues) {\r\n            // color node by metric\r\n            currentValue = state.currentValues[node.metricName];\r\n            modifyStyle(rect, {\r\n                \"fill\": gradientColorForValue(state.sortedGradient, \"fillColor\", currentValue),\r\n            });\r\n        } else {\r\n            // no data\r\n            modifyStyle(text, {\r\n                \"fill\": \"white\",\r\n            });\r\n            modifyStyle(rect, {\r\n                \"fill\": \"black\",\r\n                \"stroke-dasharray\": state.config.noValueDashArray,\r\n            });\r\n        }\r\n\r\n        if (currentValue !== null) {\r\n            let titleElem: SVGTitleElement = state.make.title();\r\n            singleNodeGroup.insertBefore(titleElem, titleElem.firstChild);\r\n            titleElem.textContent = `${node.label} (${currentValue.toFixed(2)})`;\r\n        }\r\n    }\r\n}\r\n\r\nfunction placeEdges(state: WeathermapRendererState): void {\r\n    // place edges\r\n    for (let edge of state.config.weathermapEdges) {\r\n        let node1: WeathermapNode = state.nodeLabelToNode[edge.node1];\r\n        let node2: WeathermapNode = state.nodeLabelToNode[edge.node2];\r\n        if (!node1 || !node2) {\r\n            // TODO: output error\r\n            continue;\r\n        }\r\n\r\n        let singleEdgeGroup: SVGGElement = state.make.g();\r\n        maybeWrapIntoLink(state.make, state.edgeGroup!, singleEdgeGroup, state.edgeLinkUriBase, edge.linkParams);\r\n\r\n        let n1Center: Point2D = {\r\n            x: (+node1.x) + ((+node1.width) / 2),\r\n            y: (+node1.y) + ((+node1.height) / 2)\r\n        };\r\n        let n2Center: Point2D = {\r\n            x: (+node2.x) + ((+node2.width) / 2),\r\n            y: (+node2.y) + ((+node2.height) / 2)\r\n        };\r\n\r\n        // calculate bend (control points)\r\n        let control1: Point2D|null = null;\r\n        let control2: Point2D|null = null;\r\n        if (edge.bendDirection && edge.bendMagnitude) {\r\n            // warning: screen coordinates (flipped Y axis)!\r\n            let n1N2Angle: number = Math.atan2(n1Center.y - n2Center.y, n2Center.x - n1Center.x);\r\n            let n2N1Angle: number = Math.atan2(n2Center.y - n1Center.y, n1Center.x - n2Center.x);\r\n\r\n            let n1N2BendAngle: number = normalizeAngle(n1N2Angle + deg2rad(edge.bendDirection));\r\n            let n2N1BendAngle: number = normalizeAngle(n2N1Angle - deg2rad(edge.bendDirection));\r\n\r\n            let control1Offset: Point2D = polarToCartesian(n1N2BendAngle, edge.bendMagnitude);\r\n            let control2Offset: Point2D = polarToCartesian(n2N1BendAngle, edge.bendMagnitude);\r\n\r\n            control1 = {\r\n                x: (+n1Center.x) + control1Offset.x,\r\n                y: (+n1Center.y) - control1Offset.y\r\n            };\r\n            control2 = {\r\n                x: (+n2Center.x) + control2Offset.x,\r\n                y: (+n2Center.y) - control2Offset.y\r\n            };\r\n        }\r\n\r\n        if (edge.metric2Name) {\r\n            // two metrics are twice the fun\r\n            let\r\n                [, point1COut, point2CIn, point2, point2COut, point3CIn,]\r\n            =\r\n                halveCubicBezier(n1Center, control1, control2, n2Center)\r\n            ;\r\n\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                n1Center, point1COut, point2CIn, point2,\r\n                edge.metricName, edge.styleName,\r\n                `${edge.node1} \\u2192 ${edge.node2}`\r\n            );\r\n\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                point2, point2COut, point3CIn, n2Center,\r\n                edge.metric2Name, edge.styleName,\r\n                `${edge.node2} \\u2192 ${edge.node1}`\r\n            );\r\n        } else {\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                n1Center, control1, control2, n2Center,\r\n                edge.metricName, edge.styleName,\r\n                `${edge.node1} \\u2194 ${edge.node2}`\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nfunction placeLabels(state: WeathermapRendererState): void {\r\n    for (let label of state.config.weathermapLabels) {\r\n        let singleLabelGroup: SVGGElement = state.make.g();\r\n        state.labelGroup!.appendChild(singleLabelGroup);\r\n\r\n        let text: SVGTextElement = state.make.text();\r\n        singleLabelGroup.appendChild(text);\r\n\r\n        text.setAttribute(\"x\", `${+label.x}`);\r\n        text.setAttribute(\"y\", `${+label.y}`);\r\n        text.textContent = label.label;\r\n    }\r\n}\r\n\r\nfunction makeAndPlaceEdge(\r\n    state: WeathermapRendererState, singleEdgeGroup: SVGGElement, start: Point2D, control1: Point2D|null,\r\n    control2: Point2D|null, end: Point2D, metricName: string|null|undefined, edgeStyleName: string|null|undefined,\r\n    title: string|null|undefined\r\n): void {\r\n    let strokeWidths: number[] = [state.config.strokeWidth];\r\n    let edgeStyle: WeathermapStyle|null = getWeathermapStyle(state, edgeStyleName);\r\n    if (edgeStyle && edgeStyle.strokeWidthArray) {\r\n        let pieces: string[] = edgeStyle.strokeWidthArray.split(/[ ,]+/);\r\n        strokeWidths = pieces.map(p => Number.parseFloat(p));\r\n    }\r\n\r\n    if (strokeWidths.length % 2 !== 1) {\r\n        // like stroke-dasharray, double the elements\r\n        strokeWidths.push(...strokeWidths);\r\n    }\r\n\r\n    let offsetUnitVector: Point2D = {x: 0, y: 0};\r\n    if (strokeWidths.length > 1) {\r\n        // calculate an actual offset vector\r\n\r\n        // get the direction\r\n        let direction: Point2D = {\r\n            x: start.x - end.x,\r\n            y: start.y - end.y\r\n        };\r\n\r\n        // rotate 90°; that's the offset vector\r\n        let offsetVector: Point2D = {\r\n            x: direction.y,\r\n            y: -direction.x\r\n        };\r\n\r\n        // calculate unit vector\r\n        offsetUnitVector = unitVector(offsetVector);\r\n    }\r\n\r\n    let multistrokeGroup: SVGGElement = state.make.g();\r\n    singleEdgeGroup.appendChild(multistrokeGroup);\r\n    modifyStyle(multistrokeGroup, {\r\n        \"fill\": \"none\",\r\n    });\r\n\r\n    let currentValue: number|null = null;\r\n    if (metricName != null && metricName in state.currentValues) {\r\n        currentValue = state.currentValues[metricName];\r\n        modifyStyle(multistrokeGroup, {\r\n            \"stroke\": gradientColorForValue(state.sortedGradient, \"strokeColor\", currentValue)\r\n        });\r\n        modifyApplyingWeathermapStyle(state, multistrokeGroup, edgeStyle);\r\n    } else {\r\n        modifyStyle(multistrokeGroup, {\r\n            \"stroke\": \"black\",\r\n            \"stroke-dasharray\": state.config.noValueDashArray\r\n        });\r\n    }\r\n\r\n    if (title) {\r\n        let titleElem: SVGTitleElement = state.make.title();\r\n        multistrokeGroup.appendChild(titleElem);\r\n        titleElem.textContent = (currentValue === null)\r\n            ? title\r\n            : `${title} (${currentValue.toFixed(2)})`\r\n        ;\r\n    }\r\n\r\n    let totalStrokeWidth: number = strokeWidths.reduce((acc, cur) => acc + cur, 0);\r\n    let currentOffset: number = -totalStrokeWidth/2.0;\r\n    let isSpacing: boolean = true;\r\n    for (let strokeWidth of strokeWidths) {\r\n        isSpacing = !isSpacing;\r\n        if (isSpacing) {\r\n            currentOffset += strokeWidth;\r\n            continue;\r\n        }\r\n\r\n        // calculate offset\r\n        let xOffset: number = offsetUnitVector.x * (currentOffset + strokeWidth/2.0);\r\n        let yOffset: number = offsetUnitVector.y * (currentOffset + strokeWidth/2.0);\r\n\r\n        let strokeStart: Point2D = {\r\n            x: start.x + xOffset,\r\n            y: start.y + yOffset,\r\n        };\r\n        let strokeControl1: Point2D|null = (control1 == null) ? null : {\r\n            x: control1.x + xOffset,\r\n            y: control1.y + yOffset,\r\n        };\r\n        let strokeControl2: Point2D|null = (control2 == null) ? null : {\r\n            x: control2.x + xOffset,\r\n            y: control2.y + yOffset,\r\n        };\r\n        let strokeEnd: Point2D = {\r\n            x: end.x + xOffset,\r\n            y: end.y + yOffset,\r\n        };\r\n\r\n        // make the path\r\n        let path: SVGPathElement = state.make.path();\r\n        multistrokeGroup.appendChild(path);\r\n        if (strokeControl1 == null || strokeControl2 == null) {\r\n            path.setAttribute(\"d\",\r\n                `M ${strokeStart.x},${strokeStart.y} ` +\r\n                `L ${strokeEnd.x},${strokeEnd.y}`\r\n            );\r\n        } else {\r\n            path.setAttribute(\"d\",\r\n                `M ${strokeStart.x},${strokeStart.y} ` +\r\n                `C ${strokeControl1.x},${strokeControl1.y},${strokeControl2.x},${strokeControl2.y},${strokeEnd.x},${strokeEnd.y}`\r\n            );\r\n        }\r\n\r\n        // apply the specific stroke width\r\n        modifyStyle(path, {\r\n            \"stroke-width\": `${strokeWidth}`,\r\n        });\r\n\r\n        currentOffset += strokeWidth;\r\n    }\r\n\r\n    if (state.config.showNumbers) {\r\n        let midpoint: Point2D = halveCubicBezier(start, control1, control2, end)[3];\r\n        let valueString: string = (metricName != null && metricName in state.currentValues)\r\n            ? state.currentValues[metricName].toFixed(2)\r\n            : \"?\"\r\n        ;\r\n        let text: SVGTextElement = state.make.text();\r\n        singleEdgeGroup.appendChild(text);\r\n        text.setAttribute(\"x\", `${midpoint.x}`);\r\n        text.setAttribute(\"y\", `${midpoint.y}`);\r\n        text.textContent = valueString;\r\n    }\r\n}\r\n\r\nfunction maybeWrapIntoLink(\r\n    svgMake: SVGElementCreator, upperGroup: SVGGElement, singleObjectGroup: SVGGElement,\r\n    linkUriBase: string|null|undefined, objLinkParams: string|null|undefined\r\n): void {\r\n    if (linkUriBase != null) {\r\n        let objLinkUri: string = linkUriBase;\r\n        if (objLinkParams != null) {\r\n            objLinkUri += (objLinkUri.indexOf(\"?\") === -1)\r\n                ? \"?\"\r\n                : \"&\";\r\n\r\n            objLinkUri += objLinkParams;\r\n        }\r\n\r\n        let aElement: SVGAElement = svgMake.a();\r\n        upperGroup.appendChild(aElement);\r\n        aElement.setAttributeNS(xlinkNamespace, \"href\", objLinkUri);\r\n\r\n        aElement.appendChild(singleObjectGroup);\r\n    } else {\r\n        upperGroup.appendChild(singleObjectGroup);\r\n    }\r\n}\r\n\r\nexport function setRectangleDimensions(\r\n    element: SVGRectElement, x: number|string, y: number|string, width: number|string, height: number|string\r\n): void {\r\n    element.setAttribute(\"x\", `${x}`);\r\n    element.setAttribute(\"y\", `${y}`);\r\n    element.setAttribute(\"width\", `${width}`);\r\n    element.setAttribute(\"height\", `${height}`);\r\n}\r\n\r\nfunction modifyStyle(element: Element, newValues: object): void {\r\n    // parse style\r\n    let assembledStyle: StringMapping<string> = {};\r\n    if (element.hasAttribute(\"style\")) {\r\n        let styleVal: string|null = element.getAttribute(\"style\");\r\n        if (styleVal != null) {\r\n            for (let chunk of styleVal.split(\";\")) {\r\n                let index: number = chunk.indexOf(\":\");\r\n                if (index === -1) {\r\n                    continue;\r\n                }\r\n                let key: string = chunk.substr(0, index);\r\n                let value: string = chunk.substr(index + 1);\r\n                assembledStyle[key] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let key in newValues) {\r\n        if (newValues.hasOwnProperty(key)) {\r\n            if (newValues[key] === null) {\r\n                delete assembledStyle[key];\r\n            } else {\r\n                assembledStyle[key] = newValues[key];\r\n            }\r\n        }\r\n    }\r\n\r\n    let keyValuePairs: string[] = [];\r\n    for (let key in assembledStyle) {\r\n        if (assembledStyle.hasOwnProperty(key)) {\r\n            keyValuePairs.push(`${key}:${assembledStyle[key]}`);\r\n        }\r\n    }\r\n\r\n    let keyValueString: string = keyValuePairs.join(\";\");\r\n    element.setAttribute(\"style\", keyValueString);\r\n}\r\n\r\nfunction getWeathermapStyle(\r\n    state: WeathermapRendererState, styleName: string|null|undefined\r\n): WeathermapStyle|null {\r\n    if (!styleName) {\r\n        return null;\r\n    }\r\n\r\n    let style: WeathermapStyle|undefined = state.styleMap[styleName];\r\n    if (!style) {\r\n        return null;\r\n    }\r\n    return style;\r\n}\r\n\r\nfunction modifyApplyingWeathermapStyle(\r\n    state: WeathermapRendererState, element: Element, style: WeathermapStyle|null\r\n): void {\r\n    if (!style) {\r\n        return;\r\n    }\r\n\r\n    let styleProps: StringMapping<string> = {};\r\n    if (style.dashArray) {\r\n        styleProps[\"stroke-dasharray\"] = style.dashArray;\r\n    }\r\n    // style.strokeWidthArray is handled beforehand\r\n\r\n    modifyStyle(element, styleProps);\r\n}\r\n\r\n\r\nexport class WeathermapRendererState {\r\n    make: SVGElementCreator;\r\n    config: WeathermapConfig;\r\n    sortedGradient: Gradient;\r\n    currentValues: MetricValueMap;\r\n    nodeLabelToNode: LabelToNodeMap;\r\n    nodeLinkUriBase: string|null;\r\n    edgeLinkUriBase: string|null;\r\n    svg: SVGSVGElement|null;\r\n    defs: SVGDefsElement|null;\r\n    edgeGroup: SVGGElement|null;\r\n    nodeGroup: SVGGElement|null;\r\n    labelGroup: SVGGElement|null;\r\n    legendGroup: SVGGElement|null;\r\n    styleMap: NameToStyleMap;\r\n\r\n    constructor(\r\n        domCreator: SVGElementCreatorDOM, config: WeathermapConfig, sortedGradient: Gradient, currentValues: MetricValueMap\r\n    ) {\r\n        this.make = new SVGElementCreator(domCreator);\r\n        this.config = config;\r\n        this.sortedGradient = sortedGradient;\r\n        this.currentValues = currentValues;\r\n        this.nodeLabelToNode = {};\r\n        this.nodeLinkUriBase = null;\r\n        this.edgeLinkUriBase = null;\r\n        this.svg = null;\r\n        this.defs = null;\r\n        this.edgeGroup = null;\r\n        this.nodeGroup = null;\r\n        this.labelGroup = null;\r\n        this.legendGroup = null;\r\n\r\n        this.styleMap = {};\r\n        if (config.weathermapStyles) {\r\n            for (let style of config.weathermapStyles) {\r\n                this.styleMap[style.name] = style;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class SVGElementCreator {\r\n    maker: SVGElementCreatorDOM;\r\n\r\n    constructor(maker: SVGElementCreatorDOM) { this.maker = maker; }\r\n\r\n    a() { return <SVGAElement>this.maker.createElementNS(svgNamespace, \"a\"); }\r\n    defs() { return <SVGDefsElement>this.maker.createElementNS(svgNamespace, \"defs\"); }\r\n    g() { return <SVGGElement>this.maker.createElementNS(svgNamespace, \"g\"); }\r\n    linearGradient() { return <SVGLinearGradientElement>this.maker.createElementNS(svgNamespace, \"linearGradient\"); }\r\n    path() { return <SVGPathElement>this.maker.createElementNS(svgNamespace, \"path\"); }\r\n    rect() { return <SVGRectElement>this.maker.createElementNS(svgNamespace, \"rect\"); }\r\n    stop() { return <SVGStopElement>this.maker.createElementNS(svgNamespace, \"stop\"); }\r\n    svg() { return <SVGSVGElement>this.maker.createElementNS(svgNamespace, \"svg\"); }\r\n    text() { return <SVGTextElement>this.maker.createElementNS(svgNamespace, \"text\"); }\r\n    title() { return <SVGTitleElement>this.maker.createElementNS(svgNamespace, \"title\"); }\r\n}\r\n\r\nexport interface SVGElementCreatorDOM {\r\n    createElementNS(namespaceURI: string, qualifiedName: string): Element;\r\n}\r\n\r\ninterface PositionableTextElement {\r\n    label: string;\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport interface WeathermapNode extends PositionableTextElement {\r\n    width: number;\r\n    height: number;\r\n    metricName?: string|null;\r\n    linkParams?: string;\r\n}\r\n\r\nexport interface WeathermapEdge {\r\n    node1: string;\r\n    node2: string;\r\n    bendDirection?: number;\r\n    bendMagnitude?: number;\r\n    metricName?: string;\r\n    metric2Name?: string|null;\r\n    linkParams?: string;\r\n    styleName?: string;\r\n}\r\n\r\nexport interface WeathermapLabel extends PositionableTextElement {\r\n}\r\n\r\nexport interface WeathermapStyle {\r\n    name: string;\r\n    strokeWidthArray?: string;\r\n    dashArray?: string;\r\n}\r\n\r\ninterface LinkSettings {\r\n    node: ObjectLinkSettings;\r\n    edge: ObjectLinkSettings;\r\n}\r\n\r\nexport interface StringMapping<V> {\r\n    [key: string]: V;\r\n}\r\n\r\nexport type LabelToNodeMap = StringMapping<WeathermapNode>;\r\nexport type MetricValueMap = StringMapping<number>;\r\nexport type NameToStyleMap = StringMapping<WeathermapStyle>;\r\n\r\nexport interface ObjectLinkSettings {\r\n    type: \"none\"|\"dashboard\"|\"absolute\";\r\n    dashboard: string|null;\r\n    dashUri: string|null;\r\n    absoluteUri: string|null;\r\n}\r\n\r\nexport interface WeathermapDefaultConfig {\r\n    weathermapEdges: WeathermapEdge[];\r\n    weathermapNodes: WeathermapNode[];\r\n    weathermapLabels: WeathermapLabel[];\r\n    weathermapStyles: WeathermapStyle[];\r\n    canvasSize: { width: number; height: number; };\r\n    textOffsets: { left: number; bottom: number; };\r\n    showNumbers: boolean;\r\n    valueName: \"max\"|\"min\"|\"avg\"|\"current\"|\"total\";\r\n    nullPointMode: \"connected\"|\"null\"|\"null as zero\";\r\n    strokeWidth: number;\r\n    gradient: Gradient;\r\n    legend: LegendSettings;\r\n    link: LinkSettings;\r\n    noValueDashArray: string;\r\n    unmeasuredDashArray: string;\r\n}\r\n\r\nexport interface WeathermapConfig extends WeathermapDefaultConfig {\r\n    id: number;\r\n}\r\n","import { MetricsPanelCtrl } from 'grafana/app/plugins/sdk';\r\nimport { editorPath, nodeEditorPath, edgeEditorPath, labelEditorPath, styleEditorPath } from \"./properties\";\r\nimport {\r\n    renderWeathermapInto,\r\n    WeathermapConfig,\r\n    WeathermapDefaultConfig,\r\n    WeathermapNode,\r\n    WeathermapEdge,\r\n    WeathermapLabel,\r\n    WeathermapStyle,\r\n    ObjectLinkSettings,\r\n    StringMapping\r\n} from \"./svg-weathermap/weathermap\";\r\nimport {\r\n    GradientStop\r\n} from \"./svg-weathermap/gradients\";\r\nimport _ from \"lodash\";\r\nimport TimeSeries from \"grafana/app/core/time_series2\";\r\n\r\nconst panelDefaults: WeathermapDefaultConfig = {\r\n    // data\r\n    weathermapNodes: [],\r\n    weathermapEdges: [],\r\n    weathermapLabels: [],\r\n    weathermapStyles: [],\r\n    canvasSize: {\r\n        width: 800,\r\n        height: 600\r\n    },\r\n    textOffsets: {\r\n        left: 5,\r\n        bottom: 5\r\n    },\r\n    showNumbers: false,\r\n    valueName: \"max\",\r\n    nullPointMode: \"connected\",\r\n    strokeWidth: 1,\r\n    gradient: {\r\n        type: \"steps\",\r\n        stops: []\r\n    },\r\n    legend: {\r\n        type: \"\",\r\n        x: 0,\r\n        y: 0,\r\n        length: 100,\r\n        width: 5\r\n    },\r\n    link: {\r\n        node: {\r\n            type: \"none\",\r\n            absoluteUri: null,\r\n            dashboard: null,\r\n            dashUri: null\r\n        },\r\n        edge: {\r\n            type: \"none\",\r\n            absoluteUri: null,\r\n            dashboard: null,\r\n            dashUri: null\r\n        }\r\n    },\r\n    noValueDashArray: \"4 4\",\r\n    unmeasuredDashArray: \"4 2\",\r\n};\r\n\r\nexport class WeathermapCtrl extends MetricsPanelCtrl {\r\n    static templateUrl: string;\r\n    currentValues: {[key: string]: number;};\r\n    currentSeries: object;\r\n\r\n    panel: WeathermapConfig;\r\n\r\n    searchDashboards: (queryStr: string, callback: (matches: string[]) => any) => void;\r\n\r\n    /** @ngInject **/\r\n    constructor($scope: any, $injector: any, private backendSrv: any) {\r\n        super($scope, $injector);\r\n        _.defaultsDeep(this.panel, panelDefaults);\r\n\r\n        this.currentValues = {};\r\n\r\n        this.events.on(\"init-edit-mode\", this.onInitEditMode.bind(this));\r\n        this.events.on(\"data-received\", this.onDataReceived.bind(this));\r\n        this.events.on(\"data-snapshot-load\", this.onDataSnapshotLoad.bind(this));\r\n\r\n        this.searchDashboards = function (queryStr: string, callback: (matches: string[]) => any): void {\r\n            backendSrv.search({query: queryStr}).then(hits => {\r\n                let dashboards: any[] = _.map(hits, dash => dash.title);\r\n                callback(dashboards);\r\n            });\r\n        };\r\n    }\r\n\r\n    onInitEditMode(): void {\r\n        this.addEditorTab(\"Options\", editorPath, 2);\r\n        this.addEditorTab(\"Nodes\", nodeEditorPath, 3);\r\n        this.addEditorTab(\"Edges\", edgeEditorPath, 4);\r\n        this.addEditorTab(\"Labels\", labelEditorPath, 5);\r\n        this.addEditorTab(\"Styles\", styleEditorPath, 6);\r\n    }\r\n\r\n    onDataReceived(dataList: any): void {\r\n        this.currentSeries = dataList.map(this.seriesHandler.bind(this));\r\n        this.currentValues = this.parseSeries(this.currentSeries);\r\n\r\n        this.render();\r\n    }\r\n\r\n    seriesHandler(seriesData: any): TimeSeries {\r\n        let series = new TimeSeries({\r\n            datapoints: seriesData.datapoints,\r\n            alias: seriesData.target\r\n        });\r\n        series.getFlotPairs(this.panel.nullPointMode);\r\n        return series;\r\n    }\r\n\r\n    parseSeries(series: any): StringMapping<number> {\r\n        let targetToValue: StringMapping<number> = {};\r\n        for (let ser of series) {\r\n            targetToValue[ser.alias] = ser.stats[this.panel.valueName];\r\n        }\r\n        return targetToValue;\r\n    }\r\n\r\n    onDataSnapshotLoad(snapshotData: any): void {\r\n        this.onDataReceived(snapshotData);\r\n    }\r\n\r\n    addWeathermapNode(node?: WeathermapNode): void {\r\n        this.panel.weathermapNodes.push(node || <WeathermapNode>{});\r\n    }\r\n    removeWeathermapNode(node: WeathermapNode): void {\r\n        this.panel.weathermapNodes = _.without(this.panel.weathermapNodes, node);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapEdge(edge?: WeathermapEdge): void {\r\n        this.panel.weathermapEdges.push(edge || <WeathermapEdge>{});\r\n    }\r\n    removeWeathermapEdge(edge: WeathermapEdge): void {\r\n        this.panel.weathermapEdges = _.without(this.panel.weathermapEdges, edge);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapLabel(label?: WeathermapLabel): void {\r\n        this.panel.weathermapLabels.push(label || <WeathermapLabel>{});\r\n    }\r\n    removeWeathermapLabel(label: WeathermapLabel): void {\r\n        this.panel.weathermapLabels = _.without(this.panel.weathermapLabels, label);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapStyle(style?: WeathermapStyle): void {\r\n        this.panel.weathermapStyles.push(style || <WeathermapStyle>{});\r\n    }\r\n    removeWeathermapStyle(style: WeathermapStyle): void {\r\n        this.panel.weathermapStyles = _.without(this.panel.weathermapStyles, style);\r\n        this.refresh();\r\n    }\r\n\r\n    addGradientStop(stop?: GradientStop): void {\r\n        this.panel.gradient.stops.push(stop || <GradientStop>{});\r\n    }\r\n    onGradientStopStrokeColorChange(stopIndex: number): (color: string) => void {\r\n        return (color: string) => {\r\n            this.panel.gradient.stops[stopIndex].strokeColor = color;\r\n            this.refresh();\r\n        };\r\n    }\r\n    onGradientStopFillColorChange(stopIndex: number): (color: string) => void {\r\n        return (color: string) => {\r\n            this.panel.gradient.stops[stopIndex].fillColor = color;\r\n            this.refresh();\r\n        };\r\n    }\r\n    removeGradientStop(stop: GradientStop): void {\r\n        this.panel.gradient.stops = _.without(this.panel.gradient.stops, stop);\r\n        this.refresh();\r\n    }\r\n\r\n    dashboardChanged(link: ObjectLinkSettings): void {\r\n        this.backendSrv.search({query: link.dashboard}).then((hits) => {\r\n            let dashboard: any = _.find(hits, {title: link.dashboard});\r\n            if (dashboard) {\r\n                link.dashUri = dashboard.url;\r\n            }\r\n        });\r\n    }\r\n\r\n    link(_scope: any, elems: HTMLElement[], _attrs: any, ctrl: any): void {\r\n        this.events.on(\"render\", () => this.renderThat(elems[0], ctrl));\r\n    }\r\n\r\n    renderThat(topElem: HTMLElement, _ctrl: any): void {\r\n        // find weathermap div\r\n        let elem: Element|null = topElem.querySelector(\"div.weathermap\");\r\n        if (elem === null) {\r\n            // oh well\r\n            return;\r\n        }\r\n\r\n        // filicide\r\n        while (elem.lastChild) {\r\n            elem.removeChild(elem.lastChild);\r\n        }\r\n\r\n        // do it\r\n        renderWeathermapInto(document, elem, this.panel, this.currentValues, WeathermapCtrl.resolveLink);\r\n    }\r\n\r\n    static resolveLink(objLink: ObjectLinkSettings): string|null {\r\n        if (objLink.type === \"absolute\" && objLink.absoluteUri) {\r\n            return objLink.absoluteUri;\r\n        } else if (objLink.type === \"dashboard\" && objLink.dashUri) {\r\n            let url = new URL(window.location.href);\r\n            let oldParams: StringMapping<string> = getSearchParams(url);\r\n            let params: string[] = [];\r\n\r\n            if (oldParams.from) {\r\n                params.push(`from=${encodeURIComponent(oldParams.from)}`);\r\n            }\r\n\r\n            if (oldParams.to) {\r\n                params.push(`to=${encodeURIComponent(oldParams.to)}`);\r\n            }\r\n\r\n            let paramSuffix: string = \"\";\r\n            if (params.length > 0) {\r\n                paramSuffix = \"?\" + params.join(\"&\");\r\n            }\r\n            return `${objLink.dashUri}${paramSuffix}`;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nWeathermapCtrl.templateUrl = \"partials/module.html\";\r\n\r\nfunction getSearchParams(url: URL): StringMapping<string> {\r\n    let search: string = url.search;\r\n    while (search.startsWith(\"?\")) {\r\n        search = search.substr(1);\r\n    }\r\n\r\n    let params: StringMapping<string> = {};\r\n    if (search.length > 0) {\r\n        let pairs: string[] = search.split(\"&\");\r\n        for (let pair of pairs) {\r\n            let keyValueMatch: RegExpMatchArray|null = pair.match(/^([^=]*)(?:=(.*))?$/);\r\n            if (keyValueMatch === null) {\r\n                continue;\r\n            }\r\n\r\n            let key: string = keyValueMatch[1];\r\n            let value: string = keyValueMatch[2];\r\n            if (key !== undefined && value !== undefined) {\r\n                params[decodeURIComponent(key)] = decodeURIComponent(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return params;\r\n}\r\n"],"names":["module","exports","__WEBPACK_EXTERNAL_MODULE__340__","__WEBPACK_EXTERNAL_MODULE__735__","__WEBPACK_EXTERNAL_MODULE__980__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","pluginName","editorPath","nodeEditorPath","edgeEditorPath","labelEditorPath","styleEditorPath","svgNamespace","midpoint","point1","point2","x","y","halveCubicBezier","control1","control2","straightMidpoint","m1","m2","m3","q1","q2","polarToCartesian","angleRadians","length","Math","cos","sin","normalizeAngle","PI","deg2rad","angleDegrees","emergencyColor","gradientColorForValue","gradient","colorType","type","stops","lastStop","g","b","position","foundMatch","i","posFrom","rFrom","Number","parseInt","substr","gFrom","bFrom","posTo","rTo","gTo","bTo","lerp","floor","concat","linearColorForValue","stepColorForValue","sourceMin","sourceMax","targetMin","targetMax","legendLength","placeLegend","svgMake","settings","container","defs","weathermapID","transform","strokeLegendContainer","appendChild","setAttribute","width","drawLegend","fillLegendContainer","_i","stop_2","showLegendLabel","xCoord","yCoord","dy","textAnchor","label","text","textContent","placeLabels","legendGradientName","svgGrad","linearGradient","stop_1","svgStop","stop","svgRect","rect","setRectangleDimensions","rect_1","renderWeathermapInto","elementCreator","config","currentValues","linkResolver","addViewBox","sortedStops","slice","sort","l","sortedGradient","state","WeathermapRendererState","svg","make","modifyStyle","canvasSize","height","legendGroup","edgeGroup","nodeGroup","labelGroup","initializeSVG","nodeLinkUriBase","link","node","edgeLinkUriBase","edge","weathermapNodes","nodeLabelToNode","singleNodeGroup","maybeWrapIntoLink","linkParams","textOffsets","left","bottom","showNumbers","metricName","currentValue","noValueDashArray","unmeasuredDashArray","titleElem","title","insertBefore","firstChild","toFixed","placeNodes","weathermapEdges","node1","node2","singleEdgeGroup","n1Center","n2Center","bendDirection","bendMagnitude","n1N2Angle","atan2","n2N1Angle","n1N2BendAngle","n2N1BendAngle","control1Offset","control2Offset","metric2Name","point1COut","point2CIn","point2COut","point3CIn","makeAndPlaceEdge","styleName","placeEdges","weathermapLabels","singleLabelGroup","legend","id","start","end","edgeStyleName","strokeWidths","strokeWidth","edgeStyle","style","styleMap","getWeathermapStyle","strokeWidthArray","split","map","p","parseFloat","push","apply","vector","euclidNorm","offsetUnitVector","direction","sqrt","multistrokeGroup","element","styleProps","dashArray","modifyApplyingWeathermapStyle","currentOffset","reduce","acc","cur","isSpacing","xOffset","yOffset","strokeStart","strokeControl1","strokeControl2","strokeEnd","path","valueString","upperGroup","singleObjectGroup","linkUriBase","objLinkParams","objLinkUri","indexOf","aElement","setAttributeNS","newValues","assembledStyle","hasAttribute","styleVal","getAttribute","chunk","index","keyValuePairs","keyValueString","join","domCreator","this","SVGElementCreator","weathermapStyles","name","maker","createElementNS","panelDefaults","valueName","nullPointMode","absoluteUri","dashboard","dashUri","$scope","$injector","backendSrv","_super","_this","_","panel","events","on","onInitEditMode","bind","onDataReceived","onDataSnapshotLoad","searchDashboards","queryStr","callback","search","query","then","hits","dashboards","dash","__extends","WeathermapCtrl","addEditorTab","dataList","currentSeries","seriesHandler","parseSeries","render","seriesData","series","TimeSeries","datapoints","alias","target","getFlotPairs","targetToValue","ser","stats","snapshotData","refresh","stopIndex","color","strokeColor","fillColor","url","_scope","elems","_attrs","ctrl","renderThat","topElem","_ctrl","elem","querySelector","lastChild","removeChild","document","resolveLink","objLink","oldParams","startsWith","params","keyValueMatch","match","decodeURIComponent","getSearchParams","URL","window","location","href","from","encodeURIComponent","to","paramSuffix","MetricsPanelCtrl","templateUrl"],"sourceRoot":""}