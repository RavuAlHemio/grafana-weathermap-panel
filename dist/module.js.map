{"version":3,"sources":["webpack:///./svg-weathermap/constants.ts","webpack:///./svg-weathermap/geometry.ts","webpack:///./svg-weathermap/gradients.ts","webpack:///./svg-weathermap/legend.ts","webpack:///./svg-weathermap/weathermap.ts","webpack:///./weathermapControl.ts","webpack:///./properties.ts","webpack:///external \"app/core/time_series2\"","webpack:///external \"app/plugins/sdk\"","webpack:///external \"lodash\"","webpack:///webpack/bootstrap","webpack:///webpack/startup","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object"],"names":["svgNamespace","midpoint","point1","point2","x","y","halveCubicBezier","control1","control2","straightMidpoint","m1","m2","m3","q1","q2","polarToCartesian","angleRadians","length","Math","cos","sin","normalizeAngle","PI","deg2rad","angleDegrees","emergencyColor","gradientColorForValue","gradient","colorType","value","type","stops","lastStop","r","g","b","position","foundMatch","i","posFrom","rFrom","Number","parseInt","substr","gFrom","bFrom","posTo","rTo","gTo","bTo","lerp","floor","linearColorForValue","stepColorForValue","sourceMin","sourceMax","targetMin","targetMax","legendLength","placeLegend","svgMake","settings","container","defs","weathermapID","transform","strokeLegendContainer","appendChild","setAttribute","width","drawLegend","fillLegendContainer","showLegendLabel","xCoord","yCoord","dy","textAnchor","label","text","textContent","placeLabels","legendGradientName","svgGrad","linearGradient","svgStop","stop","svgRect","rect","setRectangleDimensions","renderWeathermapInto","elementCreator","config","currentValues","linkResolver","addViewBox","sortedStops","slice","sort","l","sortedGradient","state","WeathermapRendererState","svg","make","modifyStyle","canvasSize","height","legendGroup","edgeGroup","nodeGroup","labelGroup","initializeSVG","nodeLinkUriBase","link","node","edgeLinkUriBase","edge","weathermapNodes","nodeLabelToNode","singleNodeGroup","maybeWrapIntoLink","linkParams","textOffsets","left","bottom","showNumbers","metricName","currentValue","noValueDashArray","unmeasuredDashArray","titleElem","title","insertBefore","firstChild","toFixed","placeNodes","weathermapEdges","node1","node2","singleEdgeGroup","n1Center","n2Center","bendDirection","bendMagnitude","n1N2Angle","atan2","n2N1Angle","n1N2BendAngle","n2N1BendAngle","control1Offset","control2Offset","metric2Name","point1COut","point2CIn","point2COut","point3CIn","makeAndPlaceEdge","styleName","placeEdges","weathermapLabels","singleLabelGroup","legend","id","start","end","edgeStyleName","strokeWidths","strokeWidth","edgeStyle","style","styleMap","getWeathermapStyle","strokeWidthArray","split","map","p","parseFloat","push","vector","euclidNorm","offsetUnitVector","direction","sqrt","multistrokeGroup","element","styleProps","dashArray","modifyApplyingWeathermapStyle","currentOffset","reduce","acc","cur","isSpacing","xOffset","yOffset","strokeStart","strokeControl1","strokeControl2","strokeEnd","path","valueString","upperGroup","singleObjectGroup","linkUriBase","objLinkParams","objLinkUri","indexOf","aElement","a","setAttributeNS","newValues","assembledStyle","hasAttribute","styleVal","getAttribute","chunk","index","key","hasOwnProperty","keyValuePairs","keyValueString","join","domCreator","this","SVGElementCreator","weathermapStyles","name","maker","createElementNS","panelDefaults","valueName","nullPointMode","absoluteUri","dashboard","dashUri","$scope","$injector","backendSrv","panel","events","on","onInitEditMode","bind","onDataReceived","onDataSnapshotLoad","searchDashboards","queryStr","callback","search","query","then","hits","dashboards","dash","addEditorTab","dataList","currentSeries","seriesHandler","parseSeries","render","seriesData","series","datapoints","alias","target","getFlotPairs","targetToValue","ser","stats","snapshotData","addWeathermapNode","removeWeathermapNode","refresh","addWeathermapEdge","removeWeathermapEdge","addWeathermapLabel","removeWeathermapLabel","addWeathermapStyle","removeWeathermapStyle","addGradientStop","onGradientStopStrokeColorChange","stopIndex","color","strokeColor","onGradientStopFillColorChange","fillColor","removeGradientStop","dashboardChanged","uri","_scope","elems","_attrs","ctrl","renderThat","topElem","_ctrl","elem","querySelector","lastChild","removeChild","document","WeathermapCtrl","resolveLink","objLink","oldParams","url","startsWith","params","keyValueMatch","match","undefined","decodeURIComponent","getSearchParams","URL","window","location","href","from","encodeURIComponent","to","paramSuffix","MetricsPanelCtrl","templateUrl","module","exports","__WEBPACK_EXTERNAL_MODULE__840__","__WEBPACK_EXTERNAL_MODULE__256__","__WEBPACK_EXTERNAL_MODULE__804__","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","n","getter","__esModule","d","definition","o","Object","defineProperty","enumerable","get","obj","prop","prototype","call","Symbol","toStringTag"],"mappings":"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","file":"module.js","sourcesContent":["export const svgNamespace: string = \"http://www.w3.org/2000/svg\";\r\nexport const xlinkNamespace: string = \"http://www.w3.org/1999/xlink\";\r\n","export function midpoint(point1: Point2D, point2: Point2D): Point2D {\r\n    return {\r\n        x: (point1.x + point2.x)/2.0,\r\n        y: (point1.y + point2.y)/2.0\r\n    };\r\n}\r\n\r\nexport function halveCubicBezier(\r\n    point1: Point2D, control1: Point2D|null, control2: Point2D|null, point2: Point2D\r\n): [Point2D, Point2D, Point2D, Point2D, Point2D, Point2D, Point2D] {\r\n    if (control1 === null) {\r\n        if (control2 === null) {\r\n            // naïveté!\r\n            let straightMidpoint: Point2D = midpoint(point1, point2);\r\n            return [point1, point1, straightMidpoint, straightMidpoint, straightMidpoint, point2, point2];\r\n        }\r\n\r\n        control1 = point1;\r\n    }\r\n    if (control2 === null) {\r\n        control2 = point2;\r\n    }\r\n\r\n    let m1: Point2D = midpoint(point1, control1);\r\n    let m2: Point2D = midpoint(control1, control2);\r\n    let m3: Point2D = midpoint(control2, point2);\r\n\r\n    let q1: Point2D = midpoint(m1, m2);\r\n    let q2: Point2D = midpoint(m2, m3);\r\n\r\n    let o: Point2D = midpoint(q1, q2);\r\n\r\n    return [point1, m1, q1, o, q2, m3, point2];\r\n}\r\n\r\nexport function polarToCartesian(angleRadians: number|null, length: number|null): Point2D {\r\n    if (angleRadians === null) {\r\n        angleRadians = 0;\r\n    }\r\n    if (length === null) {\r\n        length = 0;\r\n    }\r\n\r\n    return {\r\n        x: length * Math.cos(angleRadians),\r\n        y: length * Math.sin(angleRadians)\r\n    };\r\n}\r\n\r\nexport function normalizeAngle(angleRadians: number): number {\r\n    while (angleRadians <= -Math.PI) {\r\n        angleRadians += 2 * Math.PI;\r\n    }\r\n    while (angleRadians > Math.PI) {\r\n        angleRadians -= 2 * Math.PI;\r\n    }\r\n    return angleRadians;\r\n}\r\n\r\nexport function unitVector(vector: Point2D): Point2D {\r\n    let euclidNorm: number = Math.sqrt(vector.x*vector.x + vector.y*vector.y);\r\n    return {\r\n        x: vector.x / euclidNorm,\r\n        y: vector.y / euclidNorm\r\n    };\r\n}\r\n\r\nexport function deg2rad(angleDegrees: number): number {\r\n    return angleDegrees * Math.PI / 180;\r\n}\r\n\r\nexport function rad2deg(angleRadians: number): number {\r\n    return angleRadians * 180 / Math.PI;\r\n}\r\n\r\nexport interface Point2D {\r\n    x: number;\r\n    y: number;\r\n}\r\n","const emergencyColor: string = \"pink\";\r\n\r\nexport function gradientColorForValue(gradient: Gradient, colorType: keyof GradientStop, value: number): string {\r\n    if (gradient.type === \"linear\") {\r\n        return linearColorForValue(gradient.stops, colorType, value);\r\n    } else if (gradient.type === \"steps\") {\r\n        return stepColorForValue(gradient.stops, colorType, value);\r\n    }\r\n    return emergencyColor;\r\n}\r\n\r\nfunction linearColorForValue(stops: GradientStop[], colorType: keyof GradientStop, value: number): string {\r\n    if (stops.length === 0) {\r\n        return emergencyColor;\r\n    }\r\n\r\n    let lastStop: GradientStop = stops[stops.length-1];\r\n    let r: number = 0.0, g: number = 0.0, b: number = 0.0;\r\n    if (value < stops[0].position) {\r\n        return `${stops[0][colorType]}`;\r\n    } else if (value >= lastStop.position) {\r\n        return `${lastStop[colorType]}`;\r\n    } else {\r\n        let foundMatch: boolean = false;\r\n        for (let i: number = 0; i < stops.length-1; ++i) {\r\n            if (value >= stops[i].position && value < stops[i+1].position) {\r\n                // found!\r\n\r\n                let posFrom: number = stops[i].position;\r\n                let rFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(1, 2), 16);\r\n                let gFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(3, 2), 16);\r\n                let bFrom: number = Number.parseInt(`${stops[i][colorType]}`.substr(5, 2), 16);\r\n\r\n                let posTo: number = stops[i+1].position;\r\n                let rTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(1, 2), 16);\r\n                let gTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(3, 2), 16);\r\n                let bTo: number = Number.parseInt(`${stops[i+1][colorType]}`.substr(5, 2), 16);\r\n\r\n                r = lerp(value, posFrom, posTo, rFrom, rTo);\r\n                g = lerp(value, posFrom, posTo, gFrom, gTo);\r\n                b = lerp(value, posFrom, posTo, bFrom, bTo);\r\n\r\n                foundMatch = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!foundMatch) {\r\n            return emergencyColor;\r\n        }\r\n    }\r\n\r\n    return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;\r\n}\r\n\r\nfunction stepColorForValue(stops: GradientStop[], colorType: keyof GradientStop, value: number): string {\r\n    if (stops.length === 0) {\r\n        return emergencyColor;\r\n    }\r\n\r\n    let lastStop: GradientStop = stops[stops.length-1];\r\n    if (value < stops[0].position) {\r\n        return `${stops[0][colorType]}`;\r\n    } else if (value >= lastStop.position) {\r\n        return `${lastStop[colorType]}`;\r\n    } else {\r\n        for (let i: number = 0; i < stops.length-1; ++i) {\r\n            if (value >= stops[i].position && value < stops[i+1].position) {\r\n                return `${stops[i][colorType]}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    return emergencyColor;\r\n}\r\n\r\nfunction lerp(value: number, sourceMin: number, sourceMax: number, targetMin: number, targetMax: number): number {\r\n    if (targetMin === targetMax) {\r\n        return targetMin;\r\n    }\r\n\r\n    if (value < sourceMin) {\r\n        value = sourceMin;\r\n    }\r\n    if (value > sourceMax) {\r\n        value = sourceMax;\r\n    }\r\n\r\n    let terp: number = (value - sourceMin) / (sourceMax - sourceMin);\r\n    return targetMin + terp * (targetMax - targetMin);\r\n}\r\n\r\n\r\nexport interface GradientStop {\r\n    position: number;\r\n    strokeColor: string;\r\n    fillColor: string;\r\n    showLegendLabel: boolean;\r\n}\r\n\r\nexport interface Gradient {\r\n    type: \"steps\"|\"linear\";\r\n    stops: GradientStop[];\r\n}\r\n","import { Gradient, GradientStop } from \"./gradients\";\r\nimport { SVGElementCreator, setRectangleDimensions } from \"./weathermap\";\r\n\r\nconst legendLength: number = 100;\r\nconst legendWidth: number = 5;\r\n// (let the container apply any transformations)\r\n\r\nexport function placeLegend(\r\n    svgMake: SVGElementCreator, settings: LegendSettings, container: Element, defs: SVGDefsElement, gradient: Gradient,\r\n    weathermapID?: string|null\r\n): void {\r\n    let transform: string = \"\";\r\n\r\n    if (settings.type === \"\") {\r\n        // no legend\r\n        return;\r\n    }\r\n\r\n    // draw stroke-color legend\r\n    let strokeLegendContainer: SVGGElement = svgMake.g();\r\n    container.appendChild(strokeLegendContainer);\r\n    strokeLegendContainer.setAttribute(\"class\", \"stroke-legend\");\r\n    if (settings.type[0] === \"h\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y})`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    } else if (settings.type[0] === \"v\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y + settings.length})`\r\n            + ` rotate(-90)`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    }\r\n    strokeLegendContainer.setAttribute(\"transform\", transform);\r\n    drawLegend(svgMake, gradient, \"strokeColor\", strokeLegendContainer, defs, weathermapID);\r\n\r\n    // draw fill-color legend\r\n    let fillLegendContainer: SVGGElement = svgMake.g();\r\n    container.appendChild(fillLegendContainer);\r\n    strokeLegendContainer.setAttribute(\"class\", \"fill-legend\");\r\n    if (settings.type[0] === \"h\") {\r\n        transform =\r\n            `translate(${settings.x} ${settings.y + settings.width})`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    } else if (settings.type[0] === \"v\") {\r\n        transform =\r\n            `translate(${settings.x + settings.width} ${settings.y + settings.length})`\r\n            + ` rotate(-90)`\r\n            + ` scale(${settings.length/legendLength} ${settings.width/legendWidth})`\r\n        ;\r\n    }\r\n    fillLegendContainer.setAttribute(\"transform\", transform);\r\n    drawLegend(svgMake, gradient, \"fillColor\", fillLegendContainer, defs, weathermapID);\r\n\r\n    // draw legend labels\r\n    placeLabels(svgMake, settings, gradient, container);\r\n}\r\n\r\nfunction drawLegend(\r\n    svgMake: SVGElementCreator, gradient: Gradient, colorType: keyof GradientStop, container: SVGElement,\r\n    defs: SVGDefsElement, weathermapID?: string|null\r\n): void {\r\n    if (gradient.type === \"linear\") {\r\n        let legendGradientName: string = `WeathermapLegendGradient-${colorType}`;\r\n        if (weathermapID != null) {\r\n            legendGradientName = `${legendGradientName}-${weathermapID}`;\r\n        }\r\n\r\n        let svgGrad: SVGLinearGradientElement = svgMake.linearGradient();\r\n        defs.appendChild(svgGrad);\r\n        svgGrad.setAttribute(\"id\", legendGradientName);\r\n\r\n        for (let stop of gradient.stops) {\r\n            let svgStop: SVGStopElement = svgMake.stop();\r\n            svgGrad.appendChild(svgStop);\r\n            svgStop.setAttribute(\"offset\", `${stop.position}%`);\r\n            svgStop.setAttribute(\"stop-color\", `${stop[colorType]}`);\r\n        }\r\n\r\n        let svgRect: SVGRectElement = svgMake.rect();\r\n        container.appendChild(svgRect);\r\n        setRectangleDimensions(svgRect, 0, 0, legendLength, legendWidth);\r\n        svgRect.setAttribute(\"style\", `fill:url(#${legendGradientName})`);\r\n    } else if (gradient.type === \"steps\") {\r\n        for (let i: number = 1; i < gradient.stops.length; ++i) {\r\n            let rect: SVGRectElement = svgMake.rect();\r\n            container.appendChild(rect);\r\n\r\n            setRectangleDimensions(rect,\r\n                gradient.stops[i-1].position,\r\n                0,\r\n                gradient.stops[i].position - gradient.stops[i-1].position,\r\n                legendWidth\r\n            );\r\n            rect.setAttribute(\"style\", `fill:${gradient.stops[i-1][colorType]}`);\r\n        }\r\n        let rect: SVGRectElement = svgMake.rect();\r\n        container.appendChild(rect);\r\n        setRectangleDimensions(rect,\r\n            gradient.stops[gradient.stops.length-1].position,\r\n            0,\r\n            100 - gradient.stops[gradient.stops.length-1].position,\r\n            legendWidth\r\n        );\r\n        rect.setAttribute(\"style\", `fill:${gradient.stops[gradient.stops.length-1][colorType]}`);\r\n    }\r\n}\r\n\r\nfunction placeLabels(svgMake: SVGElementCreator, settings: LegendSettings, gradient: Gradient, container: Element): void {\r\n    if (settings.type === \"\" || settings.type[1] === \"n\") {\r\n        // no labels\r\n        return;\r\n    }\r\n\r\n    for (let stop of gradient.stops) {\r\n        if (!stop.showLegendLabel) {\r\n            continue;\r\n        }\r\n\r\n        let xCoord: number = settings.x;\r\n        let yCoord: number = settings.y;\r\n        let dy: number = 0.0;\r\n        let textAnchor: \"start\"|\"middle\"|\"end\" = \"start\";\r\n\r\n        if (settings.type[0] === \"h\") {\r\n            // horizontal scale\r\n            xCoord += stop.position * settings.length / legendLength;\r\n\r\n            textAnchor = \"middle\";\r\n            if (settings.type === \"hb\") {\r\n                yCoord += 2 * settings.width;\r\n                dy = 1.0;\r\n            }\r\n        } else if (settings.type[0] === \"v\") {\r\n            // vertical scale\r\n            yCoord += settings.length - (stop.position * settings.length / legendLength);\r\n            dy = 0.4;\r\n\r\n            if (settings.type === \"vl\") {\r\n                textAnchor = \"end\";\r\n            } else if (settings.type === \"vr\") {\r\n                textAnchor = \"start\";\r\n                xCoord += 2 * settings.width;\r\n            }\r\n        }\r\n\r\n        let label: SVGTextElement = svgMake.text();\r\n        container.appendChild(label);\r\n        label.setAttribute(\"class\", \"legend-label\");\r\n        label.setAttribute(\"x\", `${xCoord}`);\r\n        label.setAttribute(\"y\", `${yCoord}`);\r\n        label.setAttribute(\"dy\", `${dy}em`);\r\n        label.setAttribute(\"style\", `text-anchor:${textAnchor}`);\r\n        label.textContent = `${stop.position}`;\r\n    }\r\n}\r\n\r\nexport interface LegendSettings {\r\n    type: \"\"|\"hn\"|\"ha\"|\"hb\"|\"vn\"|\"vl\"|\"vr\";\r\n    x: number;\r\n    y: number;\r\n    length: number;\r\n    width: number;\r\n}\r\n","import { svgNamespace, xlinkNamespace } from \"./constants\";\r\nimport { deg2rad, halveCubicBezier, normalizeAngle, Point2D, polarToCartesian, unitVector } from \"./geometry\";\r\nimport { Gradient, GradientStop, gradientColorForValue } from \"./gradients\";\r\nimport { LegendSettings, placeLegend } from \"./legend\";\r\n\r\nexport function renderWeathermapInto(\r\n    elementCreator: SVGElementCreatorDOM, container: Node, config: WeathermapConfig, currentValues: MetricValueMap,\r\n    linkResolver: ((linkSettings: ObjectLinkSettings) => string|null)|null|undefined, addViewBox: boolean = false\r\n): SVGSVGElement {\r\n    // sort gradient stops\r\n    let sortedStops: GradientStop[] = config.gradient.stops\r\n        .slice()\r\n        .sort((l, r) => l.position - r.position);\r\n    let sortedGradient: Gradient = {\r\n        type: config.gradient.type,\r\n        stops: sortedStops\r\n    };\r\n\r\n    let state = new WeathermapRendererState(elementCreator, config, sortedGradient, currentValues);\r\n\r\n    initializeSVG(state, container, addViewBox);\r\n\r\n    // resolve links\r\n    if (linkResolver != null) {\r\n        state.nodeLinkUriBase = linkResolver(config.link.node);\r\n        state.edgeLinkUriBase = linkResolver(config.link.edge);\r\n    }\r\n\r\n    // emplacement\r\n    placeNodes(state);\r\n    placeEdges(state);\r\n    placeLabels(state);\r\n    placeLegend(state.make, config.legend, state.legendGroup!, state.defs!, sortedGradient, `${config.id}`);\r\n\r\n    return state.svg!;\r\n}\r\n\r\nfunction initializeSVG(state: WeathermapRendererState, container: Node, addViewBox: boolean = false): void {\r\n    // add SVG\r\n    state.svg = state.make.svg();\r\n    modifyStyle(state.svg, {\r\n        \"width\": `${state.config.canvasSize.width}px`,\r\n        \"height\": `${state.config.canvasSize.height}px`,\r\n    });\r\n    if (addViewBox) {\r\n        state.svg.setAttribute(\"viewBox\", `0 0 ${state.config.canvasSize.width} ${state.config.canvasSize.height}`);\r\n    }\r\n    container.appendChild(state.svg);\r\n\r\n    state.defs = state.make.defs();\r\n    state.svg.appendChild(state.defs);\r\n\r\n    state.legendGroup = state.make.g();\r\n    state.legendGroup.setAttribute(\"class\", \"legend\");\r\n    state.svg.appendChild(state.legendGroup);\r\n\r\n    state.edgeGroup = state.make.g();\r\n    state.edgeGroup.setAttribute(\"class\", \"edges\");\r\n    state.svg.appendChild(state.edgeGroup);\r\n\r\n    state.nodeGroup = state.make.g();\r\n    state.nodeGroup.setAttribute(\"class\", \"nodes\");\r\n    state.svg.appendChild(state.nodeGroup);\r\n\r\n    state.labelGroup = state.make.g();\r\n    state.labelGroup.setAttribute(\"class\", \"labels\");\r\n    state.svg.appendChild(state.labelGroup);\r\n}\r\n\r\nfunction placeNodes(state: WeathermapRendererState): void {\r\n    for (let node of state.config.weathermapNodes) {\r\n        state.nodeLabelToNode[node.label] = node;\r\n\r\n        let singleNodeGroup: SVGGElement = state.make.g();\r\n        maybeWrapIntoLink(state.make, state.nodeGroup!, singleNodeGroup, state.nodeLinkUriBase, node.linkParams);\r\n\r\n        let rect: SVGRectElement = state.make.rect();\r\n        singleNodeGroup.appendChild(rect);\r\n\r\n        setRectangleDimensions(rect, node.x, node.y, node.width, node.height);\r\n        modifyStyle(rect, {\r\n            \"stroke\": \"gray\",\r\n            \"stroke-width\": \"1px\",\r\n        });\r\n\r\n        let text: SVGTextElement = state.make.text();\r\n        singleNodeGroup.appendChild(text);\r\n\r\n        text.setAttribute(\"x\", `${(+node.x) + (+state.config.textOffsets.left)}`);\r\n        text.setAttribute(\"y\", `${(+node.y) + (+node.height) - state.config.textOffsets.bottom}`);\r\n        if (state.config.showNumbers && node.metricName != null) {\r\n            let value: string = (node.metricName in state.currentValues)\r\n                ? `${state.currentValues[node.metricName]}`\r\n                : \"?\"\r\n            ;\r\n            text.textContent = `${node.label} (${value})`;\r\n        } else {\r\n            text.textContent = node.label;\r\n        }\r\n\r\n        let currentValue: number|null = null;\r\n        if (!node.metricName) {\r\n            modifyStyle(rect, {\r\n                \"fill\": \"silver\",\r\n                \"stroke-dasharray\": state.config.unmeasuredDashArray,\r\n            });\r\n        } else if (node.metricName in state.currentValues) {\r\n            // color node by metric\r\n            currentValue = state.currentValues[node.metricName];\r\n            modifyStyle(rect, {\r\n                \"fill\": gradientColorForValue(state.sortedGradient, \"fillColor\", currentValue),\r\n            });\r\n        } else {\r\n            // no data\r\n            modifyStyle(text, {\r\n                \"fill\": \"white\",\r\n            });\r\n            modifyStyle(rect, {\r\n                \"fill\": \"black\",\r\n                \"stroke-dasharray\": state.config.noValueDashArray,\r\n            });\r\n        }\r\n\r\n        if (currentValue !== null) {\r\n            let titleElem: SVGTitleElement = state.make.title();\r\n            singleNodeGroup.insertBefore(titleElem, titleElem.firstChild);\r\n            titleElem.textContent = `${node.label} (${currentValue.toFixed(2)})`;\r\n        }\r\n    }\r\n}\r\n\r\nfunction placeEdges(state: WeathermapRendererState): void {\r\n    // place edges\r\n    for (let edge of state.config.weathermapEdges) {\r\n        let node1: WeathermapNode = state.nodeLabelToNode[edge.node1];\r\n        let node2: WeathermapNode = state.nodeLabelToNode[edge.node2];\r\n        if (!node1 || !node2) {\r\n            // TODO: output error\r\n            continue;\r\n        }\r\n\r\n        let singleEdgeGroup: SVGGElement = state.make.g();\r\n        maybeWrapIntoLink(state.make, state.edgeGroup!, singleEdgeGroup, state.edgeLinkUriBase, edge.linkParams);\r\n\r\n        let n1Center: Point2D = {\r\n            x: (+node1.x) + ((+node1.width) / 2),\r\n            y: (+node1.y) + ((+node1.height) / 2)\r\n        };\r\n        let n2Center: Point2D = {\r\n            x: (+node2.x) + ((+node2.width) / 2),\r\n            y: (+node2.y) + ((+node2.height) / 2)\r\n        };\r\n\r\n        // calculate bend (control points)\r\n        let control1: Point2D|null = null;\r\n        let control2: Point2D|null = null;\r\n        if (edge.bendDirection && edge.bendMagnitude) {\r\n            // warning: screen coordinates (flipped Y axis)!\r\n            let n1N2Angle: number = Math.atan2(n1Center.y - n2Center.y, n2Center.x - n1Center.x);\r\n            let n2N1Angle: number = Math.atan2(n2Center.y - n1Center.y, n1Center.x - n2Center.x);\r\n\r\n            let n1N2BendAngle: number = normalizeAngle(n1N2Angle + deg2rad(edge.bendDirection));\r\n            let n2N1BendAngle: number = normalizeAngle(n2N1Angle - deg2rad(edge.bendDirection));\r\n\r\n            let control1Offset: Point2D = polarToCartesian(n1N2BendAngle, edge.bendMagnitude);\r\n            let control2Offset: Point2D = polarToCartesian(n2N1BendAngle, edge.bendMagnitude);\r\n\r\n            control1 = {\r\n                x: (+n1Center.x) + control1Offset.x,\r\n                y: (+n1Center.y) - control1Offset.y\r\n            };\r\n            control2 = {\r\n                x: (+n2Center.x) + control2Offset.x,\r\n                y: (+n2Center.y) - control2Offset.y\r\n            };\r\n        }\r\n\r\n        if (edge.metric2Name) {\r\n            // two metrics are twice the fun\r\n            let\r\n                [, point1COut, point2CIn, point2, point2COut, point3CIn,]\r\n            =\r\n                halveCubicBezier(n1Center, control1, control2, n2Center)\r\n            ;\r\n\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                n1Center, point1COut, point2CIn, point2,\r\n                edge.metricName, edge.styleName,\r\n                `${edge.node1} \\u2192 ${edge.node2}`\r\n            );\r\n\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                point2, point2COut, point3CIn, n2Center,\r\n                edge.metric2Name, edge.styleName,\r\n                `${edge.node2} \\u2192 ${edge.node1}`\r\n            );\r\n        } else {\r\n            makeAndPlaceEdge(\r\n                state, singleEdgeGroup,\r\n                n1Center, control1, control2, n2Center,\r\n                edge.metricName, edge.styleName,\r\n                `${edge.node1} \\u2194 ${edge.node2}`\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nfunction placeLabels(state: WeathermapRendererState): void {\r\n    for (let label of state.config.weathermapLabels) {\r\n        let singleLabelGroup: SVGGElement = state.make.g();\r\n        state.labelGroup!.appendChild(singleLabelGroup);\r\n\r\n        let text: SVGTextElement = state.make.text();\r\n        singleLabelGroup.appendChild(text);\r\n\r\n        text.setAttribute(\"x\", `${+label.x}`);\r\n        text.setAttribute(\"y\", `${+label.y}`);\r\n        text.textContent = label.label;\r\n    }\r\n}\r\n\r\nfunction makeAndPlaceEdge(\r\n    state: WeathermapRendererState, singleEdgeGroup: SVGGElement, start: Point2D, control1: Point2D|null,\r\n    control2: Point2D|null, end: Point2D, metricName: string|null|undefined, edgeStyleName: string|null|undefined,\r\n    title: string|null|undefined\r\n): void {\r\n    let strokeWidths: number[] = [state.config.strokeWidth];\r\n    let edgeStyle: WeathermapStyle|null = getWeathermapStyle(state, edgeStyleName);\r\n    if (edgeStyle && edgeStyle.strokeWidthArray) {\r\n        let pieces: string[] = edgeStyle.strokeWidthArray.split(/[ ,]+/);\r\n        strokeWidths = pieces.map(p => Number.parseFloat(p));\r\n    }\r\n\r\n    if (strokeWidths.length % 2 !== 1) {\r\n        // like stroke-dasharray, double the elements\r\n        strokeWidths.push(...strokeWidths);\r\n    }\r\n\r\n    let offsetUnitVector: Point2D = {x: 0, y: 0};\r\n    if (strokeWidths.length > 1) {\r\n        // calculate an actual offset vector\r\n\r\n        // get the direction\r\n        let direction: Point2D = {\r\n            x: start.x - end.x,\r\n            y: start.y - end.y\r\n        };\r\n\r\n        // rotate 90°; that's the offset vector\r\n        let offsetVector: Point2D = {\r\n            x: direction.y,\r\n            y: -direction.x\r\n        };\r\n\r\n        // calculate unit vector\r\n        offsetUnitVector = unitVector(offsetVector);\r\n    }\r\n\r\n    let multistrokeGroup: SVGGElement = state.make.g();\r\n    singleEdgeGroup.appendChild(multistrokeGroup);\r\n    modifyStyle(multistrokeGroup, {\r\n        \"fill\": \"none\",\r\n    });\r\n\r\n    let currentValue: number|null = null;\r\n    if (metricName != null && metricName in state.currentValues) {\r\n        currentValue = state.currentValues[metricName];\r\n        modifyStyle(multistrokeGroup, {\r\n            \"stroke\": gradientColorForValue(state.sortedGradient, \"strokeColor\", currentValue)\r\n        });\r\n        modifyApplyingWeathermapStyle(state, multistrokeGroup, edgeStyle);\r\n    } else {\r\n        modifyStyle(multistrokeGroup, {\r\n            \"stroke\": \"black\",\r\n            \"stroke-dasharray\": state.config.noValueDashArray\r\n        });\r\n    }\r\n\r\n    if (title) {\r\n        let titleElem: SVGTitleElement = state.make.title();\r\n        multistrokeGroup.appendChild(titleElem);\r\n        titleElem.textContent = (currentValue === null)\r\n            ? title\r\n            : `${title} (${currentValue.toFixed(2)})`\r\n        ;\r\n    }\r\n\r\n    let totalStrokeWidth: number = strokeWidths.reduce((acc, cur) => acc + cur, 0);\r\n    let currentOffset: number = -totalStrokeWidth/2.0;\r\n    let isSpacing: boolean = true;\r\n    for (let strokeWidth of strokeWidths) {\r\n        isSpacing = !isSpacing;\r\n        if (isSpacing) {\r\n            currentOffset += strokeWidth;\r\n            continue;\r\n        }\r\n\r\n        // calculate offset\r\n        let xOffset: number = offsetUnitVector.x * (currentOffset + strokeWidth/2.0);\r\n        let yOffset: number = offsetUnitVector.y * (currentOffset + strokeWidth/2.0);\r\n\r\n        let strokeStart: Point2D = {\r\n            x: start.x + xOffset,\r\n            y: start.y + yOffset,\r\n        };\r\n        let strokeControl1: Point2D|null = (control1 == null) ? null : {\r\n            x: control1.x + xOffset,\r\n            y: control1.y + yOffset,\r\n        };\r\n        let strokeControl2: Point2D|null = (control2 == null) ? null : {\r\n            x: control2.x + xOffset,\r\n            y: control2.y + yOffset,\r\n        };\r\n        let strokeEnd: Point2D = {\r\n            x: end.x + xOffset,\r\n            y: end.y + yOffset,\r\n        };\r\n\r\n        // make the path\r\n        let path: SVGPathElement = state.make.path();\r\n        multistrokeGroup.appendChild(path);\r\n        if (strokeControl1 == null || strokeControl2 == null) {\r\n            path.setAttribute(\"d\",\r\n                `M ${strokeStart.x},${strokeStart.y} ` +\r\n                `L ${strokeEnd.x},${strokeEnd.y}`\r\n            );\r\n        } else {\r\n            path.setAttribute(\"d\",\r\n                `M ${strokeStart.x},${strokeStart.y} ` +\r\n                `C ${strokeControl1.x},${strokeControl1.y},${strokeControl2.x},${strokeControl2.y},${strokeEnd.x},${strokeEnd.y}`\r\n            );\r\n        }\r\n\r\n        // apply the specific stroke width\r\n        modifyStyle(path, {\r\n            \"stroke-width\": `${strokeWidth}`,\r\n        });\r\n\r\n        currentOffset += strokeWidth;\r\n    }\r\n\r\n    if (state.config.showNumbers) {\r\n        let midpoint: Point2D = halveCubicBezier(start, control1, control2, end)[3];\r\n        let valueString: string = (metricName != null && metricName in state.currentValues)\r\n            ? state.currentValues[metricName].toFixed(2)\r\n            : \"?\"\r\n        ;\r\n        let text: SVGTextElement = state.make.text();\r\n        singleEdgeGroup.appendChild(text);\r\n        text.setAttribute(\"x\", `${midpoint.x}`);\r\n        text.setAttribute(\"y\", `${midpoint.y}`);\r\n        text.textContent = valueString;\r\n    }\r\n}\r\n\r\nfunction maybeWrapIntoLink(\r\n    svgMake: SVGElementCreator, upperGroup: SVGGElement, singleObjectGroup: SVGGElement,\r\n    linkUriBase: string|null|undefined, objLinkParams: string|null|undefined\r\n): void {\r\n    if (linkUriBase != null) {\r\n        let objLinkUri: string = linkUriBase;\r\n        if (objLinkParams != null) {\r\n            objLinkUri += (objLinkUri.indexOf(\"?\") === -1)\r\n                ? \"?\"\r\n                : \"&\";\r\n\r\n            objLinkUri += objLinkParams;\r\n        }\r\n\r\n        let aElement: SVGAElement = svgMake.a();\r\n        upperGroup.appendChild(aElement);\r\n        aElement.setAttributeNS(xlinkNamespace, \"href\", objLinkUri);\r\n\r\n        aElement.appendChild(singleObjectGroup);\r\n    } else {\r\n        upperGroup.appendChild(singleObjectGroup);\r\n    }\r\n}\r\n\r\nexport function setRectangleDimensions(\r\n    element: SVGRectElement, x: number|string, y: number|string, width: number|string, height: number|string\r\n): void {\r\n    element.setAttribute(\"x\", `${x}`);\r\n    element.setAttribute(\"y\", `${y}`);\r\n    element.setAttribute(\"width\", `${width}`);\r\n    element.setAttribute(\"height\", `${height}`);\r\n}\r\n\r\nfunction modifyStyle(element: Element, newValues: object): void {\r\n    // parse style\r\n    let assembledStyle: StringMapping<string> = {};\r\n    if (element.hasAttribute(\"style\")) {\r\n        let styleVal: string|null = element.getAttribute(\"style\");\r\n        if (styleVal != null) {\r\n            for (let chunk of styleVal.split(\";\")) {\r\n                let index: number = chunk.indexOf(\":\");\r\n                if (index === -1) {\r\n                    continue;\r\n                }\r\n                let key: string = chunk.substr(0, index);\r\n                let value: string = chunk.substr(index + 1);\r\n                assembledStyle[key] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let key in newValues) {\r\n        if (newValues.hasOwnProperty(key)) {\r\n            if (newValues[key] === null) {\r\n                delete assembledStyle[key];\r\n            } else {\r\n                assembledStyle[key] = newValues[key];\r\n            }\r\n        }\r\n    }\r\n\r\n    let keyValuePairs: string[] = [];\r\n    for (let key in assembledStyle) {\r\n        if (assembledStyle.hasOwnProperty(key)) {\r\n            keyValuePairs.push(`${key}:${assembledStyle[key]}`);\r\n        }\r\n    }\r\n\r\n    let keyValueString: string = keyValuePairs.join(\";\");\r\n    element.setAttribute(\"style\", keyValueString);\r\n}\r\n\r\nfunction getWeathermapStyle(\r\n    state: WeathermapRendererState, styleName: string|null|undefined\r\n): WeathermapStyle|null {\r\n    if (!styleName) {\r\n        return null;\r\n    }\r\n\r\n    let style: WeathermapStyle|undefined = state.styleMap[styleName];\r\n    if (!style) {\r\n        return null;\r\n    }\r\n    return style;\r\n}\r\n\r\nfunction modifyApplyingWeathermapStyle(\r\n    state: WeathermapRendererState, element: Element, style: WeathermapStyle|null\r\n): void {\r\n    if (!style) {\r\n        return;\r\n    }\r\n\r\n    let styleProps: StringMapping<string> = {};\r\n    if (style.dashArray) {\r\n        styleProps[\"stroke-dasharray\"] = style.dashArray;\r\n    }\r\n    // style.strokeWidthArray is handled beforehand\r\n\r\n    modifyStyle(element, styleProps);\r\n}\r\n\r\n\r\nexport class WeathermapRendererState {\r\n    make: SVGElementCreator;\r\n    config: WeathermapConfig;\r\n    sortedGradient: Gradient;\r\n    currentValues: MetricValueMap;\r\n    nodeLabelToNode: LabelToNodeMap;\r\n    nodeLinkUriBase: string|null;\r\n    edgeLinkUriBase: string|null;\r\n    svg: SVGSVGElement|null;\r\n    defs: SVGDefsElement|null;\r\n    edgeGroup: SVGGElement|null;\r\n    nodeGroup: SVGGElement|null;\r\n    labelGroup: SVGGElement|null;\r\n    legendGroup: SVGGElement|null;\r\n    styleMap: NameToStyleMap;\r\n\r\n    constructor(\r\n        domCreator: SVGElementCreatorDOM, config: WeathermapConfig, sortedGradient: Gradient, currentValues: MetricValueMap\r\n    ) {\r\n        this.make = new SVGElementCreator(domCreator);\r\n        this.config = config;\r\n        this.sortedGradient = sortedGradient;\r\n        this.currentValues = currentValues;\r\n        this.nodeLabelToNode = {};\r\n        this.nodeLinkUriBase = null;\r\n        this.edgeLinkUriBase = null;\r\n        this.svg = null;\r\n        this.defs = null;\r\n        this.edgeGroup = null;\r\n        this.nodeGroup = null;\r\n        this.labelGroup = null;\r\n        this.legendGroup = null;\r\n\r\n        this.styleMap = {};\r\n        if (config.weathermapStyles) {\r\n            for (let style of config.weathermapStyles) {\r\n                this.styleMap[style.name] = style;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class SVGElementCreator {\r\n    maker: SVGElementCreatorDOM;\r\n\r\n    constructor(maker: SVGElementCreatorDOM) { this.maker = maker; }\r\n\r\n    a() { return <SVGAElement>this.maker.createElementNS(svgNamespace, \"a\"); }\r\n    defs() { return <SVGDefsElement>this.maker.createElementNS(svgNamespace, \"defs\"); }\r\n    g() { return <SVGGElement>this.maker.createElementNS(svgNamespace, \"g\"); }\r\n    linearGradient() { return <SVGLinearGradientElement>this.maker.createElementNS(svgNamespace, \"linearGradient\"); }\r\n    path() { return <SVGPathElement>this.maker.createElementNS(svgNamespace, \"path\"); }\r\n    rect() { return <SVGRectElement>this.maker.createElementNS(svgNamespace, \"rect\"); }\r\n    stop() { return <SVGStopElement>this.maker.createElementNS(svgNamespace, \"stop\"); }\r\n    svg() { return <SVGSVGElement>this.maker.createElementNS(svgNamespace, \"svg\"); }\r\n    text() { return <SVGTextElement>this.maker.createElementNS(svgNamespace, \"text\"); }\r\n    title() { return <SVGTitleElement>this.maker.createElementNS(svgNamespace, \"title\"); }\r\n}\r\n\r\nexport interface SVGElementCreatorDOM {\r\n    createElementNS(namespaceURI: string, qualifiedName: string): Element;\r\n}\r\n\r\ninterface PositionableTextElement {\r\n    label: string;\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport interface WeathermapNode extends PositionableTextElement {\r\n    width: number;\r\n    height: number;\r\n    metricName?: string|null;\r\n    linkParams?: string;\r\n}\r\n\r\nexport interface WeathermapEdge {\r\n    node1: string;\r\n    node2: string;\r\n    bendDirection?: number;\r\n    bendMagnitude?: number;\r\n    metricName?: string;\r\n    metric2Name?: string|null;\r\n    linkParams?: string;\r\n    styleName?: string;\r\n}\r\n\r\nexport interface WeathermapLabel extends PositionableTextElement {\r\n}\r\n\r\nexport interface WeathermapStyle {\r\n    name: string;\r\n    strokeWidthArray?: string;\r\n    dashArray?: string;\r\n}\r\n\r\ninterface LinkSettings {\r\n    node: ObjectLinkSettings;\r\n    edge: ObjectLinkSettings;\r\n}\r\n\r\nexport interface StringMapping<V> {\r\n    [key: string]: V;\r\n}\r\n\r\nexport type LabelToNodeMap = StringMapping<WeathermapNode>;\r\nexport type MetricValueMap = StringMapping<number>;\r\nexport type NameToStyleMap = StringMapping<WeathermapStyle>;\r\n\r\nexport interface ObjectLinkSettings {\r\n    type: \"none\"|\"dashboard\"|\"absolute\";\r\n    dashboard: string|null;\r\n    dashUri: string|null;\r\n    absoluteUri: string|null;\r\n}\r\n\r\nexport interface WeathermapDefaultConfig {\r\n    weathermapEdges: WeathermapEdge[];\r\n    weathermapNodes: WeathermapNode[];\r\n    weathermapLabels: WeathermapLabel[];\r\n    weathermapStyles: WeathermapStyle[];\r\n    canvasSize: { width: number; height: number; };\r\n    textOffsets: { left: number; bottom: number; };\r\n    showNumbers: boolean;\r\n    valueName: \"max\"|\"min\"|\"avg\"|\"current\"|\"total\";\r\n    nullPointMode: \"connected\"|\"null\"|\"null as zero\";\r\n    strokeWidth: number;\r\n    gradient: Gradient;\r\n    legend: LegendSettings;\r\n    link: LinkSettings;\r\n    noValueDashArray: string;\r\n    unmeasuredDashArray: string;\r\n}\r\n\r\nexport interface WeathermapConfig extends WeathermapDefaultConfig {\r\n    id: number;\r\n}\r\n","import { MetricsPanelCtrl } from 'grafana/app/plugins/sdk';\r\nimport { editorPath, nodeEditorPath, edgeEditorPath, labelEditorPath, styleEditorPath } from \"./properties\";\r\nimport {\r\n    renderWeathermapInto,\r\n    WeathermapConfig,\r\n    WeathermapDefaultConfig,\r\n    WeathermapNode,\r\n    WeathermapEdge,\r\n    WeathermapLabel,\r\n    WeathermapStyle,\r\n    ObjectLinkSettings,\r\n    StringMapping\r\n} from \"./svg-weathermap/weathermap\";\r\nimport {\r\n    GradientStop\r\n} from \"./svg-weathermap/gradients\";\r\nimport _ from \"lodash\";\r\nimport TimeSeries from \"grafana/app/core/time_series2\";\r\n\r\nconst panelDefaults: WeathermapDefaultConfig = {\r\n    // data\r\n    weathermapNodes: [],\r\n    weathermapEdges: [],\r\n    weathermapLabels: [],\r\n    weathermapStyles: [],\r\n    canvasSize: {\r\n        width: 800,\r\n        height: 600\r\n    },\r\n    textOffsets: {\r\n        left: 5,\r\n        bottom: 5\r\n    },\r\n    showNumbers: false,\r\n    valueName: \"max\",\r\n    nullPointMode: \"connected\",\r\n    strokeWidth: 1,\r\n    gradient: {\r\n        type: \"steps\",\r\n        stops: []\r\n    },\r\n    legend: {\r\n        type: \"\",\r\n        x: 0,\r\n        y: 0,\r\n        length: 100,\r\n        width: 5\r\n    },\r\n    link: {\r\n        node: {\r\n            type: \"none\",\r\n            absoluteUri: null,\r\n            dashboard: null,\r\n            dashUri: null\r\n        },\r\n        edge: {\r\n            type: \"none\",\r\n            absoluteUri: null,\r\n            dashboard: null,\r\n            dashUri: null\r\n        }\r\n    },\r\n    noValueDashArray: \"4 4\",\r\n    unmeasuredDashArray: \"4 2\",\r\n};\r\n\r\nexport class WeathermapCtrl extends MetricsPanelCtrl {\r\n    static templateUrl: string;\r\n    currentValues: {[key: string]: number;};\r\n    currentSeries: object;\r\n\r\n    panel: WeathermapConfig;\r\n\r\n    searchDashboards: (queryStr: string, callback: (matches: string[]) => any) => void;\r\n\r\n    /** @ngInject **/\r\n    constructor($scope: any, $injector: any, private backendSrv: any) {\r\n        super($scope, $injector);\r\n        _.defaultsDeep(this.panel, panelDefaults);\r\n\r\n        this.currentValues = {};\r\n\r\n        this.events.on(\"init-edit-mode\", this.onInitEditMode.bind(this));\r\n        this.events.on(\"data-received\", this.onDataReceived.bind(this));\r\n        this.events.on(\"data-snapshot-load\", this.onDataSnapshotLoad.bind(this));\r\n\r\n        this.searchDashboards = function (queryStr: string, callback: (matches: string[]) => any): void {\r\n            backendSrv.search({query: queryStr}).then(hits => {\r\n                let dashboards: any[] = _.map(hits, dash => dash.title);\r\n                callback(dashboards);\r\n            });\r\n        };\r\n    }\r\n\r\n    onInitEditMode(): void {\r\n        this.addEditorTab(\"Options\", editorPath, 2);\r\n        this.addEditorTab(\"Nodes\", nodeEditorPath, 3);\r\n        this.addEditorTab(\"Edges\", edgeEditorPath, 4);\r\n        this.addEditorTab(\"Labels\", labelEditorPath, 5);\r\n        this.addEditorTab(\"Styles\", styleEditorPath, 6);\r\n    }\r\n\r\n    onDataReceived(dataList: any): void {\r\n        this.currentSeries = dataList.map(this.seriesHandler.bind(this));\r\n        this.currentValues = this.parseSeries(this.currentSeries);\r\n\r\n        this.render();\r\n    }\r\n\r\n    seriesHandler(seriesData: any): TimeSeries {\r\n        let series = new TimeSeries({\r\n            datapoints: seriesData.datapoints,\r\n            alias: seriesData.target\r\n        });\r\n        series.getFlotPairs(this.panel.nullPointMode);\r\n        return series;\r\n    }\r\n\r\n    parseSeries(series: any): StringMapping<number> {\r\n        let targetToValue: StringMapping<number> = {};\r\n        for (let ser of series) {\r\n            targetToValue[ser.alias] = ser.stats[this.panel.valueName];\r\n        }\r\n        return targetToValue;\r\n    }\r\n\r\n    onDataSnapshotLoad(snapshotData: any): void {\r\n        this.onDataReceived(snapshotData);\r\n    }\r\n\r\n    addWeathermapNode(node?: WeathermapNode): void {\r\n        this.panel.weathermapNodes.push(node || <WeathermapNode>{});\r\n    }\r\n    removeWeathermapNode(node: WeathermapNode): void {\r\n        this.panel.weathermapNodes = _.without(this.panel.weathermapNodes, node);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapEdge(edge?: WeathermapEdge): void {\r\n        this.panel.weathermapEdges.push(edge || <WeathermapEdge>{});\r\n    }\r\n    removeWeathermapEdge(edge: WeathermapEdge): void {\r\n        this.panel.weathermapEdges = _.without(this.panel.weathermapEdges, edge);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapLabel(label?: WeathermapLabel): void {\r\n        this.panel.weathermapLabels.push(label || <WeathermapLabel>{});\r\n    }\r\n    removeWeathermapLabel(label: WeathermapLabel): void {\r\n        this.panel.weathermapLabels = _.without(this.panel.weathermapLabels, label);\r\n        this.refresh();\r\n    }\r\n\r\n    addWeathermapStyle(style?: WeathermapStyle): void {\r\n        this.panel.weathermapStyles.push(style || <WeathermapStyle>{});\r\n    }\r\n    removeWeathermapStyle(style: WeathermapStyle): void {\r\n        this.panel.weathermapStyles = _.without(this.panel.weathermapStyles, style);\r\n        this.refresh();\r\n    }\r\n\r\n    addGradientStop(stop?: GradientStop): void {\r\n        this.panel.gradient.stops.push(stop || <GradientStop>{});\r\n    }\r\n    onGradientStopStrokeColorChange(stopIndex: number): (color: string) => void {\r\n        return (color: string) => {\r\n            this.panel.gradient.stops[stopIndex].strokeColor = color;\r\n            this.refresh();\r\n        };\r\n    }\r\n    onGradientStopFillColorChange(stopIndex: number): (color: string) => void {\r\n        return (color: string) => {\r\n            this.panel.gradient.stops[stopIndex].fillColor = color;\r\n            this.refresh();\r\n        };\r\n    }\r\n    removeGradientStop(stop: GradientStop): void {\r\n        this.panel.gradient.stops = _.without(this.panel.gradient.stops, stop);\r\n        this.refresh();\r\n    }\r\n\r\n    dashboardChanged(link: ObjectLinkSettings): void {\r\n        this.backendSrv.search({query: link.dashboard}).then((hits) => {\r\n            let dashboard: any = _.find(hits, {title: link.dashboard});\r\n            if (dashboard) {\r\n                link.dashUri = dashboard.uri;\r\n            }\r\n        });\r\n    }\r\n\r\n    link(_scope: any, elems: HTMLElement[], _attrs: any, ctrl: any): void {\r\n        this.events.on(\"render\", () => this.renderThat(elems[0], ctrl));\r\n    }\r\n\r\n    renderThat(topElem: HTMLElement, _ctrl: any): void {\r\n        // find weathermap div\r\n        let elem: Element|null = topElem.querySelector(\"div.weathermap\");\r\n        if (elem === null) {\r\n            // oh well\r\n            return;\r\n        }\r\n\r\n        // filicide\r\n        while (elem.lastChild) {\r\n            elem.removeChild(elem.lastChild);\r\n        }\r\n\r\n        // do it\r\n        renderWeathermapInto(document, elem, this.panel, this.currentValues, WeathermapCtrl.resolveLink);\r\n    }\r\n\r\n    static resolveLink(objLink: ObjectLinkSettings): string|null {\r\n        if (objLink.type === \"absolute\" && objLink.absoluteUri) {\r\n            return objLink.absoluteUri;\r\n        } else if (objLink.type === \"dashboard\" && objLink.dashUri) {\r\n            let url = new URL(window.location.href);\r\n            let oldParams: StringMapping<string> = getSearchParams(url);\r\n            let params: string[] = [];\r\n\r\n            if (oldParams.from) {\r\n                params.push(`from=${encodeURIComponent(oldParams.from)}`);\r\n            }\r\n\r\n            if (oldParams.to) {\r\n                params.push(`to=${encodeURIComponent(oldParams.to)}`);\r\n            }\r\n\r\n            let paramSuffix: string = \"\";\r\n            if (params.length > 0) {\r\n                paramSuffix = \"?\" + params.join(\"&\");\r\n            }\r\n            return `/dashboard/${objLink.dashUri}${paramSuffix}`;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\nWeathermapCtrl.templateUrl = \"partials/module.html\";\r\n\r\nfunction getSearchParams(url: URL): StringMapping<string> {\r\n    let search: string = url.search;\r\n    while (search.startsWith(\"?\")) {\r\n        search = search.substr(1);\r\n    }\r\n\r\n    let params: StringMapping<string> = {};\r\n    if (search.length > 0) {\r\n        let pairs: string[] = search.split(\"&\");\r\n        for (let pair of pairs) {\r\n            let keyValueMatch: RegExpMatchArray|null = pair.match(/^([^=]*)(?:=(.*))?$/);\r\n            if (keyValueMatch === null) {\r\n                continue;\r\n            }\r\n\r\n            let key: string = keyValueMatch[1];\r\n            let value: string = keyValueMatch[2];\r\n            if (key !== undefined && value !== undefined) {\r\n                params[decodeURIComponent(key)] = decodeURIComponent(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return params;\r\n}\r\n","export const\r\n    pluginName: string = \"ravualhemio-weathermap-panel\",\r\n    editorPath: string = `public/plugins/${pluginName}/partials/editor.html`,\r\n    nodeEditorPath: string = `public/plugins/${pluginName}/partials/nodeEditor.html`,\r\n    edgeEditorPath: string = `public/plugins/${pluginName}/partials/edgeEditor.html`,\r\n    labelEditorPath: string = `public/plugins/${pluginName}/partials/labelEditor.html`,\r\n    styleEditorPath: string = `public/plugins/${pluginName}/partials/styleEditor.html`;\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__840__;","module.exports = __WEBPACK_EXTERNAL_MODULE__256__;","module.exports = __WEBPACK_EXTERNAL_MODULE__804__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(1);\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => module['default'] :\n\t\t() => module;\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}